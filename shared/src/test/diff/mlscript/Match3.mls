
class N
class M
//│ Defined class N
//│ Defined class M

def eval_expr v =
  case v of {
    | M -> let tmp = v.l in v
    | N -> v
    }
//│ eval_expr: (M & {l: anything} & 'a | N & 'a) -> 'a
//│          = [Function: eval_expr]

eval_expr (N {})
//│ res: N
//│    = N {}

:e
eval_expr (M {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.20: 	eval_expr (M {})
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── application of type `M` is not a 1-element tuple
//│ ║  l.20: 	eval_expr (M {})
//│ ║        	           ^^^^
//│ ╟── but it flows into argument with expected type `(?a,)`
//│ ║  l.20: 	eval_expr (M {})
//│ ║        	          ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.8: 	  case v of {
//│ ║       	       ^
//│ ╟── from receiver:
//│ ║  l.9: 	    | M -> let tmp = v.l in v
//│ ║       	                     ^
//│ ╟── Note: class M is defined at:
//│ ║  l.3: 	class M
//│ ╙──     	      ^
//│ res: error | M
//│    = M {}

def eval_expr v =
  case v of {
    | M -> let tmp = v.l in tmp
    | N -> v
    }
//│ eval_expr: (M & {l: 'l} | N & 'l) -> 'l
//│          = [Function: eval_expr1]

eval_expr (N {})
//│ res: N
//│    = N {}

:e
eval_expr (M {})
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.55: 	eval_expr (M {})
//│ ║        	^^^^^^^^^^^^^^^^
//│ ╟── application of type `M` is not a 1-element tuple
//│ ║  l.55: 	eval_expr (M {})
//│ ║        	           ^^^^
//│ ╟── but it flows into argument with expected type `(?a,)`
//│ ║  l.55: 	eval_expr (M {})
//│ ║        	          ^^^^^^
//│ ╟── Note: constraint arises from reference:
//│ ║  l.43: 	  case v of {
//│ ║        	       ^
//│ ╟── from receiver:
//│ ║  l.44: 	    | M -> let tmp = v.l in tmp
//│ ║        	                     ^
//│ ╟── Note: class M is defined at:
//│ ║  l.3: 	class M
//│ ╙──     	      ^
//│ res: error
//│    = undefined

