:AllowTypeErrors

let boolToInt x = if x then "0" else 1
//│ [ERROR] Type `string` does not match `int`
//│    
//│         (string) ---> (?a) <--- (int) 
//│    
//│ (string) comes from
//│    l.1:  let boolToInt x = if x then "0" else 1
//│                                      ^^^
//│ (?a) is assumed for
//│    l.1:  let boolToInt x = if x then "0" else 1
//│                            ^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  let boolToInt x = if x then "0" else 1
//│                                            ^
//│ boolToInt: bool -> (int | string)



// TODO add Left definition location to pattern type
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) ---> (?a) <--- (int) 
//│    
//│ (bool) comes from
//│    builtin:  let (&&): bool -> bool -> bool
//│                                        ^^^^
//│ 
//│    l.3:   | Right r -> r && true
//│                        ^^^^^^^^^^
//│ (?a) is assumed for
//│    l.1:  let destructEither x = match x with
//│                                 ^^^^^^^^^^^^
//│           | Left l -> l + 1 ...
//│           ^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.2:   | Left l -> l + 1
//│                       ^^^^^
//│ (int) comes from
//│    builtin:  let (+): int -> int -> int
//│                                  ^^^
//│ destructEither: either[int, bool] -> (bool | int)


let destructEither x = if x then
  match x with
   | Left l -> l + 1
   | Right r -> r && true
  else x
//│ [ERROR] Type `(_, _) either` does not match `int`
//│    
//│         ((_, _) either) <--- (?a) ---> (?b) <--- (int) 
//│    
//│ ((_, _) either) comes from
//│    l.3:     | Left l -> l + 1
//│               ^^^^
//│ 
//│    l.2:    match x with
//│                  ^
//│ (?a) is assumed for
//│    l.1:  let destructEither x = if x then
//│                             ^
//│ 
//│    l.5:    else x
//│                 ^^
//│ (?b) is assumed for
//│    l.1:  let destructEither x = if x then
//│                                 ^^^^^^^^^
//│            match x with ...
//│            ^^^^^^^^^^^^^^^^
//│ 
//│    l.2:    match x with
//│            ^^^^^^^^^^^^
//│             | Left l -> l + 1 ...
//│             ^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.3:     | Left l -> l + 1
//│                         ^^^^^
//│ (int) comes from
//│    builtin:  let (+): int -> int -> int
//│                                  ^^^
//│ [ERROR] Type `bool` does not match `(_, _) either`
//│    
//│         (bool) <--- (?a) ---> ((_, _) either) 
//│    
//│ (bool) comes from
//│    l.1:  let destructEither x = if x then
//│                                    ^
//│ (?a) is assumed for
//│    l.1:  let destructEither x = if x then
//│                             ^
//│ 
//│    l.2:    match x with
//│                  ^
//│ ((_, _) either) comes from
//│    l.3:     | Left l -> l + 1
//│            ^^^^
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) ---> (?a) <--- (int) 
//│    
//│ (bool) comes from
//│    builtin:  let (&&): bool -> bool -> bool
//│                                        ^^^^
//│ 
//│    l.4:     | Right r -> r && true
//│                          ^^^^^^^^^
//│ (?a) is assumed for
//│    l.2:    match x with
//│            ^^^^^^^^^^^^
//│             | Left l -> l + 1 ...
//│             ^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.3:     | Left l -> l + 1
//│                         ^^^^^
//│ (int) comes from
//│    builtin:  let (+): int -> int -> int
//│                                  ^^^
//│ destructEither: bool -> (bool | int)

let succ: int -> int
  
let test2 x = match x with
 | true -> succ x
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) <--- (?a) ---> (int) 
//│    
//│ (bool) comes from
//│    l.4:   | true -> succ x
//│             ^^^^
//│ 
//│    l.3:  let test2 x = match x with
//│                              ^
//│ (?a) is assumed for
//│    l.3:  let test2 x = match x with
//│                    ^
//│ 
//│    l.4:   | true -> succ x
//│                          ^
//│ (int) comes from
//│    l.1:  let succ: int -> int
//│                 ^^^
//│ succ: int -> int
//│ test2: nothing -> int

let g x = (not x, (if true then x else 5))
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) <--- (?a) ---> (?b) <--- (int) 
//│    
//│ (bool) comes from
//│    builtin:  let not: bool -> bool
//│                       ^^^^
//│ 
//│    l.1:  let g x = (not x, (if true then x else 5))
//│                         ^
//│ (?a) is assumed for
//│    l.1:  let g x = (not x, (if true then x else 5))
//│                ^
//│ 
//│    l.1:  let g x = (not x, (if true then x else 5))
//│                                          ^
//│ (?b) is assumed for
//│    l.1:  let g x = (not x, (if true then x else 5))
//│                            ^^^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  let g x = (not x, (if true then x else 5))
//│                                              ^
//│ g: (bool & 'a) -> (bool, int | 'a,)

// Jonathan
let confluence z = if true then z else 5
let mkpair x y = (x, confluence y)
  
let conflict x = mkpair (not x) x
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) <--- (?a) ---> (?b) <--- (int) 
//│    
//│ (bool) comes from
//│    builtin:  let not: bool -> bool
//│                       ^^^^
//│ 
//│    l.4:  let conflict x = mkpair (not x) x
//│                                       ^
//│ (?a) is assumed for
//│    l.4:  let conflict x = mkpair (not x) x
//│                       ^
//│ 
//│    l.4:  let conflict x = mkpair (not x) x
//│                                          ^
//│ 
//│    l.2:  let mkpair x y = (x, confluence y)
//│                       ^
//│ 
//│    l.2:  let mkpair x y = (x, confluence y)
//│                                          ^
//│ 
//│    l.1:  let confluence z = if true then z else 5
//│                         ^
//│ 
//│    l.1:  let confluence z = if true then z else 5
//│                                          ^
//│ (?b) is assumed for
//│    l.1:  let confluence z = if true then z else 5
//│                             ^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  let confluence z = if true then z else 5
//│                                              ^
//│ confluence: 'a -> (int | 'a)
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)
//│ conflict: (bool & 'a) -> (bool, int | 'a,)

let test =
  let f x = x in
  (f 1, f true)
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) ---> (?a) <--- (int) 
//│    
//│ (bool) comes from
//│    l.3:    (f 1, f true)
//│                    ^^^^
//│ (?a) is assumed for
//│    l.2:    let f x = x in
//│                  ^
//│ (int) comes from
//│    l.3:    (f 1, f true)
//│            ^
//│ test: (bool | int, bool | int,)



let wrap x = x :: []
let rec t = wrap (if true then 1 else t)
//│ [ERROR] Type `int` does not match `_ list`
//│    
//│         (int) ---> (?a) <--- (_ list) 
//│    
//│ (int) comes from
//│    l.2:  let rec t = wrap (if true then 1 else t)
//│                                         ^
//│ (?a) is assumed for
//│    l.2:  let rec t = wrap (if true then 1 else t)
//│                           ^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.2:  let rec t = wrap (if true then 1 else t)
//│                                                ^
//│ 
//│    l.2:  let rec t = wrap (if true then 1 else t)
//│                  ^
//│ 
//│    l.2:  let rec t = wrap (if true then 1 else t)
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list) comes from
//│    l.1:  let wrap x = x :: []
//│                    ^^^^^^^
//│ wrap: 'a -> list['a]
//│ t: 't
//│   where
//│     't :> list[int | 't]
