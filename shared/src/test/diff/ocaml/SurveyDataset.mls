:AllowTypeErrors

// easy 1
let boolToInt x = if x then "0" else 1
//│ ╔══[ERROR] Type `string` does not match `int`
//│ ║  
//│ ╟── this `then` branch has type `string`
//│ ║  l.1: 	let boolToInt x = if x then "0" else 1
//│ ║       	                            ^^^
//│ ╟── this if-then-else expression has type `string`
//│ ║  l.1: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.1: 	let boolToInt x = if x then "0" else 1
//│ ║       	                  ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `else` branch has type `int`
//│ ║  l.1: 	let boolToInt x = if x then "0" else 1
//│ ╙──     	                                     ^

// easy 2
let destructEither x = match x with
 | Left l -> l + 1
 | Right r -> r && true
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟──        bool ---> ?a <--- int 
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ║  builtin: 	let (&&): bool -> bool -> bool
//│ ║           	                          ^^^^
//│ ╟── this operator application has type `bool` and it flows into `?a`
//│ ║  l.3: 	 | Right r -> r && true
//│ ║       	              ^^^^^^^^^^
//│ ╟── this match expression has type `?a`
//│ ║  l.1: 	let destructEither x = match x with
//│ ║       	                       ^^^^^^^^^^^^
//│ ║  l.2: 	 | Left l -> l + 1 ...
//│ ║       	^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `?a` and it flows from `int`
//│ ║  l.2: 	 | Left l -> l + 1
//│ ║       	             ^^^^^
//│ ╟── this type reference has type `int`
//│ ║  builtin: 	let (+): int -> int -> int
//│ ╙──         	                       ^^^

// easy 3
let destructEither x y = if y then
  match x with
    | Left l -> l && true
    | Right r -> r || false
  else x
//│ ╔══[ERROR] Type `bool` does not match `(?a, ?b) either`
//│ ║  
//│ ╟── `bool` comes from this type expression
//│ ║  builtin: 	let (||): bool -> bool -> bool
//│ ║           	                          ^^^^
//│ ╟── this operator application has type `bool`
//│ ║  l.4: 	    | Right r -> r || false
//│ ║       	                 ^^^^^^^^^^
//│ ╟── this variable has type `(?a, ?b) either`
//│ ║  l.1: 	let destructEither x y = if y then
//│ ║       	                   ^
//│ ╟── this reference has type `(?a, ?b) either`
//│ ║  l.2: 	  match x with
//│ ║       	        ^
//│ ╟── this pattern has type `(?a, ?b) either`
//│ ║  l.3: 	    | Left l -> l && true
//│ ╙──     	      ^^^^

// med 1
// FIXME no common prov error
let wrap x = x :: []
let test z = if true then wrap z else wrap true
let rec t = test (if true then 1 else t)
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.1: 	let wrap x = x :: []
//│ ║       	             ^^^^^^^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.3: 	let rec t = test (if true then 1 else t)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `int`
//│ ║  l.3: 	let rec t = test (if true then 1 else t)
//│ ╙──     	                               ^
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.1: 	let wrap x = x :: []
//│ ║       	             ^^^^^^^
//│ ╟── this if-then-else expression has type `int`
//│ ║  l.3: 	let rec t = test (if true then 1 else t)
//│ ║       	                 ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `int`
//│ ║  l.3: 	let rec t = test (if true then 1 else t)
//│ ╙──     	                               ^

// med 2
let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0
  
let x l = List.map string_of_int
  
let y = [1, 2, 3]
  
let rec mulByDigit i l =
  match List.rev l with
  | [] -> []
  | h::t -> [remainder x y] @ (mulByDigit i t)
//│ ╔══[ERROR] Type `?a list` does not match `int`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.5: 	let y = [1, 2, 3]
//│ ║       	        ^^^^^^^^^
//│ ╟── this application has type `int`
//│ ║  l.5: 	let y = [1, 2, 3]
//│ ║       	        ^^^^^^^^^
//│ ╟── this reference has type `int`
//│ ║  l.10: 	  | h::t -> [remainder x y] @ (mulByDigit i t)
//│ ║        	                         ^
//│ ╟── this variable has type `int`
//│ ║  l.1: 	let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0
//│ ║       	                ^
//│ ╟── this reference has type `int`
//│ ║  l.1: 	let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0
//│ ║       	                                                  ^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let ( * ): int -> int -> int
//│ ╙──         	                  ^^^
//│ ╔══[ERROR] Type `?a -> ?b` does not match `int`
//│ ║  
//│ ╟── this function has type `?a -> ?b`
//│ ║  l.3: 	let x l = List.map string_of_int
//│ ║       	      ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?a -> ?b`
//│ ║  l.10: 	  | h::t -> [remainder x y] @ (mulByDigit i t)
//│ ║        	                       ^
//│ ╟── this variable has type `?a -> ?b`
//│ ║  l.1: 	let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0
//│ ║       	              ^
//│ ╟── this variable has type `int`
//│ ║  l.1: 	let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0
//│ ║       	              ^
//│ ╟── this reference has type `int`
//│ ║  l.1: 	let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0
//│ ║       	                                              ^
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let ( * ): int -> int -> int
//│ ╙──         	           ^^^

// med 3
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10]
  
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t)
  
let digits n = digitsOfInt (abs n)
  
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true
//│ ╔══[ERROR] Type `bool` does not match `int`
//│ ║  
//│ ╟── this `else` branch has type `bool`
//│ ║  l.11: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true
//│ ║        	                                                         ^^^^^
//│ ╟── this if-then-else expression has type `bool`
//│ ║  l.11: 	  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true
//│ ║        	            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `int`
//│ ║  l.9: 	  match digits n with
//│ ║       	  ^^^^^^^^^^^^^^^^^^^
//│ ║  l.10: 	  | [] -> 0 ...
//│ ║        	^^^^^^^^^^^
//│ ╟── this integer literal has type `int`
//│ ║  l.10: 	  | [] -> 0
//│ ╙──      	          ^



// med 4
let rec assoc (d,k,l) =
  match l with
  | [] -> d
  | h::t -> let (f,s) = h in if k = f then s h else assoc d k t
//│ ╔══[ERROR] Type `?a -> ?b` does not match `?c * ?a * ?d`
//│ ║  
//│ ╟──        ?a -> ?b <--- ?c ---> ?c * ?a * ?d 
//│ ║  
//│ ╟── this application has type `?a -> ?b`
//│ ║  l.4: 	  | h::t -> let (f,s) = h in if k = f then s h else assoc d k t
//│ ║       	                                                    ^^^^^^^
//│ ╟── this match expression has type `?a -> ?b`
//│ ║  l.2: 	  match l with
//│ ║       	  ^^^^^^^^^^^^
//│ ║  l.3: 	  | [] -> d ...
//│ ║       	^^^^^^^^^^^
//│ ╟── this reference has type `?a -> ?b` and it flows from `?c`
//│ ║  l.3: 	  | [] -> d
//│ ║       	          ^
//│ ╟── this variable has type `?c`
//│ ║  l.1: 	let rec assoc (d,k,l) =
//│ ║       	               ^
//│ ╟── this reference has type `?c` and it flows into `?c * ?a * ?d`
//│ ║  l.4: 	  | h::t -> let (f,s) = h in if k = f then s h else assoc d k t
//│ ║       	                                                          ^
//│ ╟── this tuple literal has type `?c * ?a * ?d`
//│ ║  l.1: 	let rec assoc (d,k,l) =
//│ ╙──     	              ^^^^^^^


// hard 1
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1))
  
let addTuple (l1,l2) = l1 + l2
  
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t
  
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2)
  
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = mod (a + x) 10 in
    let base = 0 in
    let args = List.map addTuple (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2))
//│ ╔══[ERROR] Type `int` does not match `?a * ?b`
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let mod: int -> int -> int
//│ ║           	                       ^^^
//│ ╟── this application has type `int`
//│ ║  l.18: 	    let f a x = mod (a + x) 10 in
//│ ║        	                ^^^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b`
//│ ║  l.21: 	    let (_,res) = List.fold_left f base args in res in
//│ ║        	                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?a * ?b`
//│ ║  l.21: 	    let (_,res) = List.fold_left f base args in res in
//│ ╙──      	        ^^^^^^^

// hard 2
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1))
  
let padZero l1 l2 =
  let numZeros = (List.length l1) - (List.length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2))
  
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l
  
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (carry,currentSum) = a in
      if x = []
      then (0, (carry :: currentSum))
      else
        (let (toSum1,toSum2) = x in
         let intermediateValue = (toSum1 + toSum2) + carry in
         let valueToAddToArray = intermediateValue mod 10 in
         let carry = intermediateValue / 10 in
         (carry, (valueToAddToArray :: currentSum))) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2))
//│ ╔══[ERROR] Type `int` does not match `(int -> int -> int) -> ?a`
//│ ║  
//│ ╟── `int` comes from this type expression
//│ ║  builtin: 	let (+): int -> int -> int
//│ ║           	                       ^^^
//│ ╟── this operator application has type `int`
//│ ║  l.23: 	         let intermediateValue = (toSum1 + toSum2) + carry in
//│ ║        	                                 ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `(int -> int -> int) -> ?a`
//│ ║  l.23: 	         let intermediateValue = (toSum1 + toSum2) + carry in
//│ ║        	                                 ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `(int -> int -> int) -> ?a`
//│ ║  l.24: 	         let valueToAddToArray = intermediateValue mod 10 in
//│ ╙──      	                                 ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?b * ?c` does not match `?a list`
//│ ║  
//│ ╟── `?b * ?c` comes from this type expression
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ║           	                                         ^^^^^^^
//│ ╟── this reference has type `?a list`
//│ ║  l.19: 	      if x = []
//│ ╙──      	             ^^

// hard 3
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l
  
let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]")
//│ ╔══[ERROR] Type `string` does not match `?a * ?b -> ?c`
//│ ║  
//│ ╟── `string` comes from this type expression
//│ ║  builtin: 	let (^): string -> string -> string
//│ ║           	                             ^^^^^^
//│ ╟── this operator application has type `string`
//│ ║  l.5: 	      let f a x = a ^ (sep ^ x) in
//│ ║       	                  ^^^^^^^^^^^^^
//│ ╟── this match expression has type `?a * ?b -> ?c`
//│ ║  l.2: 	  match sl with
//│ ║       	  ^^^^^^^^^^^^^
//│ ║  l.3: 	  | [] -> "" ...
//│ ║       	^^^^^^^^^^^^
//│ ╟── this application has type `?a * ?b -> ?c`
//│ ║  l.8: 	let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]")
//│ ╙──     	                               ^^^^^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `(?b -> ?c) -> ?b list -> ?c list` does not match `?a list`
//│ ║  
//│ ╟── `(?b -> ?c) -> ?b list -> ?c list` comes from this type expression
//│ ║  builtin: 	let List.map: ('a -> 'b) -> 'a list -> 'b list
//│ ║           	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `(?b -> ?c) -> ?b list -> ?c list`
//│ ║  l.8: 	let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]")
//│ ║       	                                              ^^^^^^^^
//│ ╟── this variable has type `(?b -> ?c) -> ?b list -> ?c list`
//│ ║  l.1: 	let rec sepConcat sep sl =
//│ ║       	                      ^^
//│ ╟── this variable has type `?a list`
//│ ║  l.1: 	let rec sepConcat sep sl =
//│ ║       	                      ^^
//│ ╟── this reference has type `?a list`
//│ ║  l.2: 	  match sl with
//│ ║       	        ^^
//│ ╟── this pattern has type `?a list`
//│ ║  l.3: 	  | [] -> ""
//│ ╙──     	    ^^
