let rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;
 
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
 
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
 
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
 
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
 
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (x1,x2) = x in
      let (carry,res) = a in
      ((((x1 + x2) + carry) / 10), ((mod ((x1 + x2) + carry) 10) :: res)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (carry,res) = List.fold_left f base args in [carry] @ res in
  removeZero (add (padZero l1 l2));;
 
let rec mulByDigit i l =
  let f a x =
    let carry = i * x in
    match a with
    | h::t -> ((h + carry) / 10) :: (mod (h + carry) 10) :: t
    | _ -> [carry / 10; mod carry 10] in
  let base = [] in removeZero (List.fold_left f base (List.rev l));;
  
let bigMul l1 l2 =
  let f a x =
    let (x1,x2) = x in
    let (carry,res) = a in
    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
  let base = (0, []) in
  let args = l1 (tenEx 0 l2) in
  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ╔══[ERROR] Type `?a list` does not match `?b -> ?c`
//│ ║  
//│ ╟──        ?a list ---> ?d <--- ?b -> ?c 
//│ ║  
//│ ╟── this reference has type `?a list` and it flows into `?d`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                          ^^
//│ ╟── this match expression has type `?d`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?d` and it flows from `?b -> ?c`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this function has type `?b -> ?c`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	              ^^^^
//│ ║  l.20: 	  let add (l1,l2) = ...
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `int * ?a0 list`
//│ ║  
//│ ╟──        ?a list ---> ?b <--- int * ?a0 list 
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                          ^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a list`
//│ ║  l.41: 	    let (carry,res) = a in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a list` and it flows into `?b`
//│ ║  l.40: 	    let (x1,x2) = x in
//│ ║        	    ^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	    let (carry,res) = a in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?b`
//│ ║  l.45: 	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?b` and it flows from `int * ?a0 list`
//│ ║  l.45: 	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║        	                                     ^^^^
//│ ╟── this tuple literal has type `int * ?a0 list`
//│ ║  l.43: 	  let base = (0, []) in
//│ ╙──      	             ^^^^^^^
//│ ╔══[ERROR] Type `?b -> ?c` does not match `int * ?a list`
//│ ║  
//│ ╟──        ?b -> ?c ---> ?d <--- int * ?a list 
//│ ║  
//│ ╟── this function has type `?b -> ?c`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	              ^^^^
//│ ║  l.20: 	  let add (l1,l2) = ...
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?b -> ?c`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?b -> ?c`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b -> ?c`
//│ ║  l.41: 	    let (carry,res) = a in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?b -> ?c` and it flows into `?d`
//│ ║  l.40: 	    let (x1,x2) = x in
//│ ║        	    ^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	    let (carry,res) = a in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?d`
//│ ║  l.45: 	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `?d` and it flows from `int * ?a list`
//│ ║  l.45: 	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║        	                                     ^^^^
//│ ╟── this tuple literal has type `int * ?a list`
//│ ║  l.43: 	  let base = (0, []) in
//│ ╙──      	             ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b * ?c`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                          ^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a list`
//│ ║  l.41: 	    let (carry,res) = a in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a list`
//│ ║  l.40: 	    let (x1,x2) = x in
//│ ║        	    ^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	    let (carry,res) = a in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a list`
//│ ║  l.45: 	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?b * ?c`
//│ ║  l.45: 	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ╙──      	      ^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a -> ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this function has type `?a -> ?b`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	              ^^^^
//│ ║  l.20: 	  let add (l1,l2) = ...
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a -> ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?a -> ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a -> ?b`
//│ ║  l.41: 	    let (carry,res) = a in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a -> ?b`
//│ ║  l.40: 	    let (x1,x2) = x in
//│ ║        	    ^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	    let (carry,res) = a in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a -> ?b`
//│ ║  l.45: 	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ║        	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?c * ?d`
//│ ║  l.45: 	  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ ╙──      	      ^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b * ?c`
//│ ║  
//│ ╟── this reference has type `?a list`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                          ^^
//│ ╟── this match expression has type `?a list`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a list`
//│ ║  l.41: 	    let (carry,res) = a in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a list`
//│ ║  l.40: 	    let (x1,x2) = x in
//│ ║        	    ^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	    let (carry,res) = a in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?b * ?c`
//│ ║  l.41: 	    let (carry,res) = a in
//│ ╙──      	        ^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a -> ?b` does not match `?c * ?d`
//│ ║  
//│ ╟── this function has type `?a -> ?b`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	              ^^^^
//│ ║  l.20: 	  let add (l1,l2) = ...
//│ ║        	^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `?a -> ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this match expression has type `?a -> ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a -> ?b`
//│ ║  l.41: 	    let (carry,res) = a in
//│ ║        	    ^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this let expression has type `?a -> ?b`
//│ ║  l.40: 	    let (x1,x2) = x in
//│ ║        	    ^^^^^^^^^^^^^^^^^^
//│ ║  l.41: 	    let (carry,res) = a in ...
//│ ║        	^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this pattern has type `?c * ?d`
//│ ║  l.41: 	    let (carry,res) = a in
//│ ╙──      	        ^^^^^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c list`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	           ^^
//│ ╟── this reference has type `?a * ?b`
//│ ║  l.28: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                           ^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.5: 	let padZero l1 l2 =
//│ ║       	            ^^
//│ ╟── `?c list` comes from this type expression
//│ ║  builtin: 	let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│ ╙──         	                  ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c list`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	           ^^
//│ ╟── this reference has type `?a * ?b`
//│ ║  l.28: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                           ^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.5: 	let padZero l1 l2 =
//│ ║       	            ^^
//│ ╟── `?c list` comes from this type expression
//│ ║  builtin: 	let (@): 'a list -> 'a list -> 'a list
//│ ╙──         	                    ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c list`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	           ^^
//│ ╟── this reference has type `?a * ?b`
//│ ║  l.28: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                           ^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.5: 	let padZero l1 l2 =
//│ ║       	            ^^
//│ ╟── `?c list` comes from this type expression
//│ ║  builtin: 	let List.length: 'a list -> int
//│ ╙──         	                 ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c list`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	           ^^
//│ ╟── this reference has type `?a * ?b`
//│ ║  l.28: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                           ^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.5: 	let padZero l1 l2 =
//│ ║       	            ^^
//│ ╟── `?c list` comes from this type expression
//│ ║  builtin: 	let List.length: 'a list -> int
//│ ╙──         	                 ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c list`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	           ^^
//│ ╟── this reference has type `?a * ?b`
//│ ║  l.28: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                           ^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.5: 	let padZero l1 l2 =
//│ ║       	            ^^
//│ ╟── `?c list` comes from this type expression
//│ ║  builtin: 	let List.length: 'a list -> int
//│ ╙──         	                 ^^^^^^^
//│ ╔══[ERROR] Type `?a * ?b` does not match `?c list`
//│ ║  
//│ ╟── this tuple literal has type `?a * ?b`
//│ ║  l.42: 	    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│ ║        	                                              ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.19: 	let bigAdd l1 l2 =
//│ ║        	           ^^
//│ ╟── this reference has type `?a * ?b`
//│ ║  l.28: 	  removeZero (add (padZero l1 l2));;
//│ ║        	                           ^^
//│ ╟── this variable has type `?a * ?b`
//│ ║  l.5: 	let padZero l1 l2 =
//│ ║       	            ^^
//│ ╟── `?c list` comes from this type expression
//│ ║  builtin: 	let List.length: 'a list -> int
//│ ╙──         	                 ^^^^^^^
//│ ╔══[ERROR] Type `?a list` does not match `?b -> ?c`
//│ ║  
//│ ╟──        ?a list <--- ?d ---> ?b -> ?c 
//│ ║  
//│ ╟── `?a list` comes from this type expression
//│ ║  builtin: 	let List.rev: 'a list -> 'a list
//│ ║           	              ^^^^^^^
//│ ╟── this reference has type `?a list` and it flows from `?d`
//│ ║  l.36: 	  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ ║        	                                                               ^
//│ ╟── this variable has type `?d`
//│ ║  l.30: 	let rec mulByDigit i l =
//│ ║        	                     ^
//│ ╟── this variable has type `?e` and it flows into `?b -> ?c`
//│ ║  l.38: 	let bigMul l1 l2 =
//│ ║        	           ^^
//│ ╟── this reference has type `?b -> ?c`
//│ ║  l.44: 	  let args = l1 (tenEx 0 l2) in
//│ ╙──      	             ^^
//│ helper: int -> int
//│ clone: 'a -> int -> list['a]
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: list['a] -> list['a]
//│ tenEx: int -> list[int] -> list[int]
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ mulByDigit: int -> list[int] -> list[int]
//│ bigMul: nothing -> list[int] -> list[int]
