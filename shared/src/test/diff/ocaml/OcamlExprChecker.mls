:NoLibrary
:AllowTypeErrors

// library type definitions and functions
type 'a option = None | Some of 'a
let raise: 'a -> nothing
exception Error
//│ Defined type alias option[+'a]
//│ Defined class None
//│ Defined class Some[+'a]
//│ None: option[nothing]
//│ Some: 'a -> option['a]
//│ raise: anything -> nothing
//│ Error: anything

let List.length: 'a list -> int
let List.mem: 'a -> 'a list -> bool
let List.append: 'a list -> 'a list -> 'a list
//│ List.length: list[?] -> int
//│ List.mem: anything -> list[?] -> bool
//│ List.append: list['a] -> list['a] -> list['a]

let (@): 'a list -> 'a list -> 'a list
Cons(1, Nil) @ Cons(2, Nil)
//│ @: list['a] -> list['a] -> list['a]
//│ res: list[int]

// equality check
// FIXME
let a b c = b = c
let a b c d = b = c = d
//│ a: anything -> anything -> bool
//│ a: anything -> anything -> anything -> bool

// list values
1 :: Nil
1 :: 2 :: Nil
[1, 2, 3, 4]
[]
// let a = []
//│ res: list[int]
//│ res: list[int]
//│ res: list[(int, int, int, int,)]
//│ res: list[nothing]

let (+.): float -> float -> float
let (-.): float -> float -> float
let ( *. ): float -> float -> float
let ( /. ): float -> float -> float
let ( ** ): float -> float -> float
//│ +.: float -> float -> float
//│ -.: float -> float -> float
//│ *.: float -> float -> float
//│ /.: float -> float -> float
//│ **: float -> float -> float

1.0 +. 1.0 -. 1.0 *. 2.0 /. 3.0 ** 5.0
//│ res: float

1.0 :: Nil
2.0 :: 3.223 :: Nil
//│ res: list[float]
//│ res: list[float]

let f = 3.14
let f = f +. 1.0
let f = f +. f +. 1.0
//│ f: float
//│ f: float
//│ f: float

let (+): int -> int -> int
//│ +: int -> int -> int

// let without in as definitions
let a = 1
let a = a + 1
let a = a + a + 1
//│ a: int
//│ a: int
//│ a: int

let a = ("hi", 2)
let b = ("bye", 3)
let data = Cons (a, Cons (b, Nil))
//│ a: (string, int,)
//│ b: (string, int,)
//│ data: list[(string, int,)]

2.0
let b = 3.0
let c = 3.0 +. 4.0 *. 6.0
//│ res: float
//│ b: float
//│ c: float

// make tuples from comma separated terms
1, 2, 3
let mktup = 1, 2, 3
let mktup = 1, (2, 3)
let mktup = [1, 2, 3], 4, (5, 6)
//│ res: (int, int, int,)
//│ mktup: (int, int, int,)
//│ mktup: (int, (int, int,),)
//│ mktup: (list[(int, int, int,)], int, (int, int,),)

// create classes for exceptions
exception Unimplemented
exception AlreadyDone
raise Unimplemented
raise AlreadyDone
//│ ╔══[ERROR] Type `anything` does not match `anything`
//│ ║  
//│ ╟── this reference has type `anything`
//│ ║  l.4: 	raise AlreadyDone
//│ ║       	      ^^^^^^^^^^^
//│ ╟── this reference has type `anything`
//│ ║  l.4: 	raise AlreadyDone
//│ ╙──     	      ^^^^^^^^^^^
//│ Unimplemented: anything
//│ AlreadyDone: anything
//│ res: nothing
//│ res: nothing

// type definitions
type heapVar = HeapInt of int | Heap of heap and heap = (string * int) list
//│ Defined type alias heapVar
//│ Defined class HeapInt
//│ Defined class Heap
//│ Defined type alias heap
//│ HeapInt: int -> heapVar
//│ Heap: heap -> heapVar

type exp = Int of int | Var of string | Plus of exp * exp | Times of exp * exp
//│ Defined type alias exp
//│ Defined class Int
//│ Defined class Var
//│ Defined class Plus
//│ Defined class Times
//│ Int: int -> exp
//│ Var: string -> exp
//│ Plus: (exp, exp,) -> exp
//│ Times: (exp, exp,) -> exp

type stmt = Skip | Assign of string * exp
         | Seq of stmt * stmt 
         | If of exp * stmt * stmt
         | While of exp * stmt 
         | SaveHeap of string
         | RestoreHeap of string
//│ Defined type alias stmt
//│ Defined class Skip
//│ Defined class Assign
//│ Defined class Seq
//│ Defined class If
//│ Defined class While
//│ Defined class SaveHeap
//│ Defined class RestoreHeap
//│ Skip: stmt
//│ Assign: (string, exp,) -> stmt
//│ Seq: (stmt, stmt,) -> stmt
//│ If: (exp, stmt, stmt,) -> stmt
//│ While: (exp, stmt,) -> stmt
//│ SaveHeap: string -> stmt
//│ RestoreHeap: string -> stmt

// parameterized type definitions
type 'a heapA = HeapA of 'a
type ('a, 'b) heapB = HeapB of ('a * 'b)
type ('a, 'b) heapC = HeapC of ('a * 'b) list
type ('a, 'b) heapD = HeapD of 'a * 'b list
//│ Defined type alias heapA[+'a]
//│ Defined class HeapA[+'a]
//│ Defined type alias heapB[+'a, +'b]
//│ Defined class HeapB[+'a, +'b]
//│ Defined type alias heapC[+'a, +'b]
//│ Defined class HeapC[+'a, +'b]
//│ Defined type alias heapD[+'a, +'b]
//│ Defined class HeapD[+'a, +'b]
//│ HeapA: 'a -> heapA['a]
//│ HeapB: ('a, 'b,) -> heapB['a, 'b]
//│ HeapC: list[('a, 'b,)] -> heapC['a, 'b]
//│ HeapD: ('a, list['b],) -> heapD['a, 'b]

(("hi", 1) :: Nil)
(("hi", 1) :: Nil):heap
(("hi", 1) :: ("bye", 2) :: Nil):heap
//│ ╔══[ERROR] Type `?a list` does not match `heap`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.3: 	(("hi", 1) :: ("bye", 2) :: Nil):heap
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `heap`
//│ ║  l.3: 	(("hi", 1) :: ("bye", 2) :: Nil):heap
//│ ║       	^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── `heap` comes from this type expression
//│ ║  l.3: 	(("hi", 1) :: ("bye", 2) :: Nil):heap
//│ ╙──     	                                 ^^^^
//│ ╔══[ERROR] Type `?a list` does not match `heap`
//│ ║  
//│ ╟── this application has type `?a list`
//│ ║  l.2: 	(("hi", 1) :: Nil):heap
//│ ║       	^^^^^^^^^^^^^^^^^^
//│ ╟── this application has type `heap`
//│ ║  l.2: 	(("hi", 1) :: Nil):heap
//│ ║       	^^^^^^^^^^^^^^^^^^
//│ ╟── `heap` comes from this type expression
//│ ║  l.2: 	(("hi", 1) :: Nil):heap
//│ ╙──     	                   ^^^^
//│ res: list[(string, int,)]
//│ res: heap
//│ res: heap

let update h str i = (str,i)::h
//│ update: list['a] -> 'b -> 'c -> list['a | ('b, 'c,)]

/// FIXME
// define lambdas using fun
fun (env: env) _ -> []
let interp2 = (fun (env:env) opt ->
  match opt with
     None -> 0)
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  
//│ ║  l.219: 	fun (env: env) _ -> []
//│ ╙──       	    ^^^^^^^^^^^^
//│ res: error -> list[nothing]
//│ ╔══[ERROR] Unsupported pattern shape:
//│ ║  
//│ ║  l.220: 	let interp2 = (fun (env:env) opt ->
//│ ╙──       	                   ^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: opt
//│ ║  
//│ ║  l.221: 	  match opt with
//│ ╙──       	        ^^^
//│ interp2: error -> int

let head xs = match xs with
  Cons(x, xs) -> x
  | _ -> raise Error
//│ ╔══[ERROR] Type `anything` does not match `anything`
//│ ║  
//│ ╟── this reference has type `anything`
//│ ║  l.3: 	  | _ -> raise Error
//│ ║       	               ^^^^^
//│ ╟── this reference has type `anything`
//│ ║  l.3: 	  | _ -> raise Error
//│ ╙──     	               ^^^^^
//│ head: list['a] -> 'a



let head xs = match xs with
  x :: xs -> x
  | _ -> raise Error
//│ ╔══[ERROR] Type `anything` does not match `anything`
//│ ║  
//│ ╟── this reference has type `anything`
//│ ║  l.3: 	  | _ -> raise Error
//│ ║       	               ^^^^^
//│ ╟── this reference has type `anything`
//│ ║  l.3: 	  | _ -> raise Error
//│ ╙──     	               ^^^^^
//│ head: list['a] -> 'a

type ('a) bigHeap =
  NoHeap of 'a list
  | NonHeap of otherList
  | NonsHeap of (otherList * 'a) list
  and otherList = int list
//│ Defined type alias bigHeap[+'a]
//│ Defined class NoHeap[+'a]
//│ Defined class NonHeap
//│ Defined class NonsHeap[+'a]
//│ Defined type alias otherList
//│ NoHeap: list['a] -> bigHeap['a]
//│ NonHeap: otherList -> bigHeap[nothing]
//│ NonsHeap: list[(otherList, 'a,)] -> bigHeap['a]

:dp
type biglist = int option list
type listoflists = int list list
type stringintlist = ((string * int) list * int) list
type ('a, 'b) paramlist = (('a * int) list * 'b) list
//│ Parsed: TypeDef(Als, TypeName(biglist), List(), AppliedType(TypeName(list),List(AppliedType(TypeName(option),List(TypeName(int))))), List())
//│ TypeDef(Als, TypeName(listoflists), List(), AppliedType(TypeName(list),List(AppliedType(TypeName(list),List(TypeName(int))))), List())
//│ TypeDef(Als, TypeName(stringintlist), List(), AppliedType(TypeName(list),List(Tuple(List(AppliedType(TypeName(list),List(Tuple(List(TypeName(string), TypeName(int))))), TypeName(int))))), List())
//│ TypeDef(Als, TypeName(paramlist), List(TypeName('a), TypeName('b)), AppliedType(TypeName(list),List(Tuple(List(AppliedType(TypeName(list),List(Tuple(List(TypeName('a), TypeName(int))))), TypeName('b))))), List())
//│ Defined type alias biglist
//│ Defined type alias listoflists
//│ Defined type alias stringintlist
//│ Defined type alias paramlist[+'a, +'b]



let check (v: ((int, int))) =
  match v with
   ((c, d)) -> c + d
//│ check: (int, int,) -> int

// TODO: confusing float with int
let checkagain (v: (int, int, (int, int))) =
  match v with
   (a, b, (c, d)) -> a + b + c + d
//│ ╔══[ERROR] Type `float` does not match `int`
//│ ║  
//│ ╟── `float` comes from this type expression
//│ ║  l.-255: 	let (+.): float -> float -> float
//│ ║          	                            ^^^^^
//│ ╟── this operator application has type `float`
//│ ║  l.-209: 	let c = 3.0 +. 4.0 *. 6.0
//│ ║          	        ^^^^^^^^^^^^^^^^^
//│ ╟── this operator application has type `int`
//│ ║  l.-209: 	let c = 3.0 +. 4.0 *. 6.0
//│ ║          	        ^^^^^^^^^^^^^^^^^
//│ ╟── this reference has type `int`
//│ ║  l.3: 	   (a, b, (c, d)) -> a + b + c + d
//│ ║       	                             ^
//│ ╟── `int` comes from this type expression
//│ ║  l.-229: 	let (+): int -> int -> int
//│ ╙──        	                ^^^
//│ ╔══[ERROR] identifier not found: d
//│ ║  
//│ ║  l.304: 	   (a, b, (c, d)) -> a + b + c + d
//│ ╙──       	              ^
//│ ╔══[ERROR] identifier not found: d
//│ ║  
//│ ║  l.304: 	   (a, b, (c, d)) -> a + b + c + d
//│ ╙──       	                                 ^
//│ checkagain: (int, int, (int, int,),) -> int

let (<): 'a -> 'a -> bool
//│ <: anything -> anything -> bool

:dp
let temp n = 
  match n < 0 with
    true  -> 0
    | false  -> 1
//│ Parsed: Def(false, temp, Lam(Var(n), If(App(App(Var(<), Var(n)), IntLit(0)), List(IfThen(Var(true), IntLit(0), IfThen(Var(false), IntLit(1)))), true)
//│ temp: anything -> int

let (-): int -> int -> int
let (+): int -> int -> int
let ( * ): int -> int -> int
//│ -: int -> int -> int
//│ +: int -> int -> int
//│ *: int -> int -> int

let check a b =
  let (sum, sub) = (a + b, a - b) in sum * sub
//│ check: int -> int -> int

let d x =
  let (hd :: tl) = x in hd
//│ d: list['a] -> 'a
