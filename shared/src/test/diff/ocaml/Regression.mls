:AllowTypeErrors


:e
let test =
  let f x = x in
  (f 1 + f true)
//│ [ERROR] Type `bool` does not match `int`
//│    
//│ `bool` comes from
//│    l.3:    (f 1 + f true)
//│                     ^^^^
//│ `bool` comes from
//│    l.2:    let f x = x in
//│                  ^
//│ 
//│    l.3:    (f 1 + f true)
//│            ^
//│ test: int

// TODO: show error
let test2 = let (a, b) = test in [[b]] + 1
//│ test2: int

// TODO: show error
let f x = x + 1
not (f 1)
//│ f: int -> int
//│ res: bool

// TODO: show error
:d
let a = 1
not a
//│ 1. Typing term 1
//│ 1. : int
//│ ⬤ Typed as: int
//│  where: 
//│ 0. Typing term not a
//│ | 0. Typing term not
//│ | 0. : [(bool -> bool)]
//│ | 0. Typing term a
//│ | 0. : [int]
//│ | CONSTRAIN [int] <! bool
//│ |   where 
//│ | C [int] <! bool    (0) where ProvType <: TypeRef}
//│ | | C int <! bool    (0) where TypeRef <: TypeRef}
//│ | | | !! COLLISION ERROR (List(int, [int]),List(bool))
//│ 0. : [bool]
//│ ⬤ Typed as: [bool]
//│  where: 
//│ a: int
//│ res: bool


let confluence z = if true then z else 5
confluence true
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) ---> (?a) <--- (int) 
//│    
//│ (bool) comes from
//│    l.2:  confluence true
//│                     ^^^^
//│ 
//│    l.1:  let confluence z = if true then z else 5
//│                         ^
//│ 
//│    l.1:  let confluence z = if true then z else 5
//│                                          ^
//│ (?a) is assumed for
//│    l.1:  let confluence z = if true then z else 5
//│                             ^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  let confluence z = if true then z else 5
//│                                              ^
//│ confluence: 'a -> (int | 'a)
//│ res: bool | int


let x: int list
let y: string list
let f: string list -> unit
//│ x: list[int]
//│ y: list[string]
//│ f: list[string] -> unit

// TODO: this won't show error because there are no type variables
f x

// Should show
// ╔══[ERROR] Type `string list` does not match `int list`
// ║  
// ╟──        string list ---> ?a <--- int list 
// ║  
// ╟── `string list` comes from this type expression
// ║  l.-10: 	let y: string list
// ║         	       ^^^^^^^^^^^
// ╟── this `else` branch has type `string list` and it flows into `?a`
// ║  l.1: 	if true then x else y
// ║       	                    ^
// ╟── this if-then-else expression has type `?a`
// ║  l.1: 	if true then x else y
// ║       	^^^^^^^^^^^^^^^^^^^^^
// ╟── this `then` branch has type `?a` and it flows from `int list`
// ║  l.1: 	if true then x else y
// ║       	             ^
// ╟── this applied type reference has type `int list`
// ║  l.-11: 	let x: int list
// ╙──       	       ^^^^^^^^
// res: list[int | string]
if true then x else y
//│ [ERROR] Type `string list` does not match `int list`
//│    
//│         (string list) ---> (?a) <--- (int list) 
//│    
//│ (string list) comes from
//│    l.-29:  let y: string list
//│                   ^^^^^^^^^^^
//│ 
//│    l.1:  if true then x else y
//│                              ^
//│ (?a) is assumed for
//│    l.1:  if true then x else y
//│          ^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.1:  if true then x else y
//│                       ^
//│ (int list) comes from
//│    l.-30:  let x: int list
//│                ^^^^^^^^
//│ res: list[int | string]

// TODO: show error
Left 1 : int
//│ res: int


let confluence z = if true then z else 5
let mkpair x y = (x, confluence y)
mkpair 1 "2"
//│ [ERROR] Type `string` does not match `int`
//│    
//│         (string) ---> (?a) <--- (int) 
//│    
//│ (string) comes from
//│    l.3:  mkpair 1 "2"
//│                   ^^^
//│ 
//│    l.2:  let mkpair x y = (x, confluence y)
//│                       ^
//│ 
//│    l.2:  let mkpair x y = (x, confluence y)
//│                                          ^
//│ 
//│    l.1:  let confluence z = if true then z else 5
//│                         ^
//│ 
//│    l.1:  let confluence z = if true then z else 5
//│                                          ^
//│ (?a) is assumed for
//│    l.1:  let confluence z = if true then z else 5
//│                             ^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  let confluence z = if true then z else 5
//│                                              ^
//│ confluence: 'a -> (int | 'a)
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)
//│ res: (int, int | string,)

// TODO nested prov not shown in collision error
let a = 1
let b = a
let f x = if x then true else false
let g = f
g b
//│ [ERROR] Type `bool` does not match `string list`
//│    
//│ `bool` comes from
//│    l.3:  let f x = if x then true else false
//│                       ^
//│ `bool` comes from
//│    l.3:  let f x = if x then true else false
//│                ^
//│ 
//│    l.-88:  let f: string list -> unit
//│                ^^^^^^^^^^^
//│ [ERROR] Type `bool` does not match `unit`
//│    
//│ `bool` comes from
//│    l.3:  let f x = if x then true else false
//│                                        ^^^^^
//│ `bool` comes from
//│    l.3:  let f x = if x then true else false
//│                    ^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.-88:  let f: string list -> unit
//│                               ^^^^
//│ a: int
//│ b: int
//│ bool -> bool
//│   <:  f:
//│ list[string] -> unit
//│ g: list[string] -> unit

let wrap x = x :: []
  
// TODO: show error
if true then wrap 1 else wrap true
//│ wrap: 'a -> list['a]


if true then wrap (if true then 1 else false) else wrap true
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) ---> (?a) <--- (int) 
//│    
//│ (bool) comes from
//│    l.1:  if true then wrap (if true then 1 else false) else wrap true
//│                                                 ^^^^^
//│ (?a) is assumed for
//│    l.1:  if true then wrap (if true then 1 else false) else wrap true
//│                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  if true then wrap (if true then 1 else false) else wrap true
//│                                       ^
//│ res: list[bool | int]


let rec t = wrap (if true then 1 else t)
//│ [ERROR] Type `_ list` does not match `int`
//│    
//│         (_ list) ---> (?a) <--- (int) 
//│    
//│ (_ list) comes from
//│    l.-23:  let wrap x = x :: []
//│                         ^^^^^^^
//│ 
//│    l.1:  let rec t = wrap (if true then 1 else t)
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.1:  let rec t = wrap (if true then 1 else t)
//│                  ^
//│ 
//│    l.1:  let rec t = wrap (if true then 1 else t)
//│                                                ^
//│ (?a) is assumed for
//│    l.1:  let rec t = wrap (if true then 1 else t)
//│                           ^^^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  let rec t = wrap (if true then 1 else t)
//│                                      ^
//│ t: 't
//│   where
//│     't :> list[int | 't]


let test z = if true then wrap z else wrap true
 
let rec m = test (if true then 1 else m)
//│ [ERROR] Type `int` does not match `_ list`
//│    
//│         (int) ---> (?a) <--- (_ list) 
//│    
//│ (int) comes from
//│    l.3:  let rec m = test (if true then 1 else m)
//│                                         ^
//│ (?a) is assumed for
//│    l.3:  let rec m = test (if true then 1 else m)
//│                           ^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.3:  let rec m = test (if true then 1 else m)
//│                                                ^
//│ 
//│    l.3:  let rec m = test (if true then 1 else m)
//│                  ^
//│ 
//│    l.3:  let rec m = test (if true then 1 else m)
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.1:  let test z = if true then wrap z else wrap true
//│                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.1:  let test z = if true then wrap z else wrap true
//│                                    ^^^^^^
//│ (_ list) comes from
//│    l.-51:  let wrap x = x :: []
//│                      ^^^^^^^
//│ [ERROR] Type `int` does not match `_ list`
//│    
//│         (int) ---> (?a) <--- (_ list) 
//│    
//│ (int) comes from
//│    l.3:  let rec m = test (if true then 1 else m)
//│                                         ^
//│ (?a) is assumed for
//│    l.3:  let rec m = test (if true then 1 else m)
//│                           ^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.3:  let rec m = test (if true then 1 else m)
//│                                                ^
//│ 
//│    l.3:  let rec m = test (if true then 1 else m)
//│                  ^
//│ 
//│    l.3:  let rec m = test (if true then 1 else m)
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.1:  let test z = if true then wrap z else wrap true
//│                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.1:  let test z = if true then wrap z else wrap true
//│                                                ^^^^^^^^^
//│ (_ list) comes from
//│    l.-51:  let wrap x = x :: []
//│                      ^^^^^^^
//│ test: 'a -> list[bool | 'a]
//│ m: 'm
//│   where
//│     'm :> list[int | 'm | bool]


// FIXME implementation exception
let rec digitsOfInt n =
  ((digitsOfInt n) / 10) @ [remainder];;
//│ [ERROR] Type `_ list` does not match `int`
//│    
//│ `_ list` comes from
//│    builtin:  let (@): 'a list -> 'a list -> 'a list
//│                                             ^^^^^^^
//│ 
//│    l.2:    ((digitsOfInt n) / 10) @ [remainder];;
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ `_ list` comes from
//│    l.2:    ((digitsOfInt n) / 10) @ [remainder];;
//│             ^^^^^^^^^^^^^^^
//│ 
//│    builtin:  let ( / ): int -> int -> int
//│                      ^^^
//│ [ERROR] Type `error` does not match `error`
//│    
//│         (error) ---> (?a) <--- (?a0) ---> (?b) <--- (error) 
//│    
//│ (error) comes from and it flows into `?a`
//│    l.2:    ((digitsOfInt n) / 10) @ [remainder];;
//│                                      ^^^^^^^^^
//│ Exception empty list for (ub('a237' <: ['a236']),false)
//│ TODO: Exception empty list for (lb([['a237']] <: α230'),true)
//│ (error) comes from
//│    l.2:    ((digitsOfInt n) / 10) @ [remainder];;
//│                                   ^^^^^^^^^
//│ ╔══[ERROR] identifier not found: remainder
//│    
//│    l.325:    ((digitsOfInt n) / 10) @ [remainder];;
//│                                     ^^^^^^^^^
//│ digitsOfInt: anything -> list[error]
