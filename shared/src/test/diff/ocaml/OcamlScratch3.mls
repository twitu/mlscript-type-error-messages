:AllowTypeErrors



// TODO nested prov not shown in collision error
let a = 1
let b = a
let f x = if x then true else false
let g = f
g b
//│ ╔══[ERROR] Type `int` does not match `bool`
//│ ║  
//│ ╟── this integer literal has type `int`
//│ ║  l.1: 	let a = 1
//│ ║       	        ^
//│ ╟── this reference has type `int`
//│ ║  l.2: 	let b = a
//│ ║       	        ^
//│ ╟── this reference has type `int`
//│ ║  l.5: 	g b
//│ ║       	  ^
//│ ╟── this variable has type `int`
//│ ║  l.3: 	let f x = if x then true else false
//│ ╙──     	      ^
//│ a: int
//│ b: int
//│ f: bool -> bool
//│ g: bool -> bool
//│ res: bool


// TODO nested prov not shown in collision error
let a = 1
let b = a
let f x y = if y then x else "x"
let g = f
g b true
//│ ╔══[ERROR] Type `string` does not match `int`
//│ ║  
//│ ╟──        string ---> ?a <--- int 
//│ ║  
//│ ╟── this `else` branch has type `string` and it flows into `?a`
//│ ║  l.3: 	let f x y = if y then x else "x"
//│ ║       	                             ^^^
//│ ╟── this if-then-else expression has type `?a`
//│ ║  l.3: 	let f x y = if y then x else "x"
//│ ║       	            ^^^^^^^^^^^^^^^^^^^^
//│ ╟── this `then` branch has type `?a`
//│ ║  l.3: 	let f x y = if y then x else "x"
//│ ║       	                      ^
//│ ╟── this variable has type `?a`
//│ ║  l.3: 	let f x y = if y then x else "x"
//│ ║       	      ^
//│ ╟── this reference has type `?a`
//│ ║  l.5: 	g b true
//│ ║       	  ^
//│ ╟── this reference has type `?a` and it flows from `int`
//│ ║  l.2: 	let b = a
//│ ║       	        ^
//│ ╟── this integer literal has type `int`
//│ ║  l.1: 	let a = 1
//│ ╙──     	        ^
//│ a: int
//│ b: int
//│ f: 'a -> bool -> (string | 'a)
//│ g: 'a -> bool -> (string | 'a)
//│ res: int | string
