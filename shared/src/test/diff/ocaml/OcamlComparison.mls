////////// file 1935

////////// ocamlc error
//
// File "1935.ml", line 22, characters 18-44:
// 22 |     let (_,res) = List.fold_left f base args in res in
//                        ^^^^^^^^^^^^^^^^^^^^^^^^^^
// Error: This expression has type int but an expression was expected of type
//          'a * 'b

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let addTuple (l1,l2) = l1 + l2;;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
//│ [ERROR] Type `_ * _ list` does not match `_ list * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ * _) 
//│    
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                ^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list * _`
//│    
//│         (_ * _) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                   ^^^^^^^^
//│ (?a) is assumed for
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ addTuple: (int, int,) -> int
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: list['a] -> list['a]


let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a + x) mod 10 in
    let base = 0 in
    let args = List.map addTuple (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `_ * _` does not match `_ list * _`
//│    
//│         (_ * _) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _) comes from
//│    l.-63:      else (l1, l2);;
//│                     ^^^^^^^^
//│ (?a) is assumed for
//│    l.-65:      if (List.length l1) < (List.length l2)
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.-64:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list * _` does not match `_ * _ list`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ list * _) comes from
//│    l.-64:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.-65:      if (List.length l1) < (List.length l2)
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.-68:    if (List.length l1) > (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.-67:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ * _ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ * _) comes from
//│    l.-63:      else (l1, l2);;
//│                     ^^^^^^^^
//│ 
//│    l.-65:      if (List.length l1) < (List.length l2)
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.-68:    if (List.length l1) > (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.-67:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `int`
//│    
//│         (_ * _) <--- (?a) ---> (int) 
//│    
//│ (_ * _) comes from
//│    l.6:      let (_,res) = List.fold_left f base args in res in
//│                  ^^^^^^^
//│ (?a) is assumed for
//│    l.6:      let (_,res) = List.fold_left f base args in res in
//│                            ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.3:      let f a x = (a + x) mod 10 in
//│                    ^
//│ 
//│    l.3:      let f a x = (a + x) mod 10 in
//│                           ^
//│ (int) comes from
//│    builtin:  let (+): int -> int -> int
//│                    ^^^
//│ bigAdd: list[int] -> list[int] -> list[nothing]

////////// file 0003

////////// ocamlc error
//
// File "0003.ml", line 23, characters 31-32:
// 23 |         (let (toSum1,toSum2) = x in
//                                     ^
// Error: This expression has type 'a list
//        but an expression was expected of type 'b * 'c

let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let numZeros = (List.length l1) - (List.length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
//│ [ERROR] Type `_ list * _` does not match `_ * _ list`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ list * _) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                                                ^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                 ^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list * _` does not match `_ * _`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _) 
//│    
//│ (_ list * _) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                                                ^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.5:    if numZeros = 0
//│            ^^^^^^^^^^^^^^^
//│            then (l1, l2) ...
//│            ^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.6:    then (l1, l2)
//│              ^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ * _) 
//│    
//│ (_ * _ list) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                    ^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.5:    if numZeros = 0
//│            ^^^^^^^^^^^^^^^
//│            then (l1, l2) ...
//│            ^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.6:    then (l1, l2)
//│              ^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: (list[int] & 'a & 'b) -> 'a
//│   where
//│     'a := 'b
//│     'b := 'a

:unify
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (carry,currentSum) = a in
      if x = []
      then (0, (carry :: currentSum))
      else
        (let (toSum1,toSum2) = x in
         let intermediateValue = (toSum1 + toSum2) + carry in
         let valueToAddToArray = intermediateValue mod 10 in
         let carry = intermediateValue / 10 in
         (carry, (valueToAddToArray :: currentSum))) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `_ list * _` does not match `_ * _ list`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ list * _) comes from
//│    l.-59:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                                                  ^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.-59:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.-59:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                   ^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list * _`
//│    
//│         (_ * _) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _) comes from
//│    l.-62:    then (l1, l2)
//│                   ^^^^^^^^
//│ (?a) is assumed for
//│    l.-63:    if numZeros = 0
//│              ^^^^^^^^^^^^^^^
//│            then (l1, l2) ...
//│            ^^^^^^^^^^^^^^^^^
//│ 
//│    l.-59:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.-59:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                                               ^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ * _ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ * _) comes from
//│    l.-62:    then (l1, l2)
//│                   ^^^^^^^^
//│ (?a) is assumed for
//│    l.-63:    if numZeros = 0
//│              ^^^^^^^^^^^^^^^
//│            then (l1, l2) ...
//│            ^^^^^^^^^^^^^^^^^
//│ 
//│    l.-59:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.-59:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                   ^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `int * _ list`
//│    
//│         (int * _ list) ---> (?a) <--- (int * _ list) 
//│    
//│ (int * _ list) comes from
//│    l.13:      let base = (0, []) in
//│                          ^^^^^^^
//│ (?a) is assumed for
//│    l.15:      let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│ 
//│    l.4:        let (carry,currentSum) = a in
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│                if x = [] ...
//│                ^^^^^^^^^^^^^
//│ 
//│    l.5:        if x = []
//│                ^^^^^^^^^
//│                then (0, (carry :: currentSum)) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (int * _ list) comes from
//│    l.6:        then (0, (carry :: currentSum))
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `int * _ list`
//│    
//│         (int * _ list) ---> (?a) <--- (int * _ list) 
//│    
//│ (int * _ list) comes from
//│    l.12:           (carry, (valueToAddToArray :: currentSum))) in
//│                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:          (let (toSum1,toSum2) = x in
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│                   let intermediateValue = (toSum1 + toSum2) + carry in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:        if x = []
//│                ^^^^^^^^^
//│                then (0, (carry :: currentSum)) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:        let (carry,currentSum) = a in
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│                if x = [] ...
//│                ^^^^^^^^^^^^^
//│ 
//│    l.15:      let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│ (int * _ list) comes from
//│    l.13:      let base = (0, []) in
//│                       ^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `int * _ list`
//│    
//│         (int * _ list) ---> (?a) <--- (int * _ list) 
//│    
//│ (int * _ list) comes from
//│    l.12:           (carry, (valueToAddToArray :: currentSum))) in
//│                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:          (let (toSum1,toSum2) = x in
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│                   let intermediateValue = (toSum1 + toSum2) + carry in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.5:        if x = []
//│                ^^^^^^^^^
//│                then (0, (carry :: currentSum)) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (int * _ list) comes from
//│    l.6:        then (0, (carry :: currentSum))
//│                  ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ list) 
//│    
//│ (_ * _) comes from
//│    builtin:  let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                                       ^^^^^^^
//│ 
//│    l.3:      let f a x =
//│                      ^
//│ (?a) is assumed for
//│    l.5:        if x = []
//│                   ^
//│ (_ list) comes from
//│    l.5:        if x = []
//│                    ^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│    
//│         (_ list) ---> (?a) <--- (?b) ---> (_ * _) 
//│    
//│ (_ list) comes from and it flows into `?a`
//│    l.5:        if x = []
//│                       ^^
//│ 
//│    l.5:        if x = []
//│                   ^
//│ (?b) is assumed for
//│    l.3:      let f a x =
//│                      ^
//│ 
//│    l.8:          (let (toSum1,toSum2) = x in
//│                                         ^
//│ (_ * _) comes from
//│    l.8:          (let (toSum1,toSum2) = x in
//│                    ^^^^^^^^^^^^^^^
//│ bigAdd: list[int] -> list[int] -> list[int]

////////// file 1948

////////// ocamlc error
//
// File "1948.ml", line 43, characters 46-70:
// 43 |     match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//                                                    ^^^^^^^^^^^^^^^^^^^^^^^^
// Error: This expression has type 'a * 'b
//        but an expression was expected of type int list

let rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (x1,x2) = x in
      let (carry,res) = a in
      ((((x1 + x2) + carry) / 10), ((mod ((x1 + x2) + carry) 10) :: res)) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (carry,res) = List.fold_left f base args in [carry] @ res in
  removeZero (add (padZero l1 l2));;
let rec mulByDigit i l =
  let f a x =
    let carry = i * x in
    match a with
    | h::t -> ((h + carry) / 10) :: (mod (h + carry) 10) :: t
    | _ -> [carry / 10; mod carry 10] in
  let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│ [ERROR] Type `_ list * _` does not match `_ * _`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _) 
//│    
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                ^^^^^^^^
//│ [ERROR] Type `_ list * _` does not match `_ * _`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _) 
//│    
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                ^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ list * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ * _) 
//│    
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                ^^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `int * _ list`
//│    
//│         (int * _ list) ---> (?a) <--- (int * _ list) 
//│    
//│ (int * _ list) comes from
//│    l.20:      let base = (0, []) in
//│                          ^^^^^^^
//│ (?a) is assumed for
//│    l.22:      let (carry,res) = List.fold_left f base args in [carry] @ res in
//│                                                  ^^^^
//│ 
//│    l.17:        let (x1,x2) = x in
//│                 ^^^^^^^^^^^^^^^^^^
//│                let (carry,res) = a in ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.18:        let (carry,res) = a in
//│                 ^^^^^^^^^^^^^^^^^^^^^^
//│                ((((x1 + x2) + carry) / 10), ((mod ((x1 + x2) + carry) 10) :: res)) in
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (int * _ list) comes from
//│    l.19:        ((((x1 + x2) + carry) / 10), ((mod ((x1 + x2) + carry) 10) :: res)) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list * _` does not match `_ * _ list`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ * _ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                   ^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ helper: int -> int
//│ clone: 'a -> int -> list['a]
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: list['a] -> list['a]
//│ tenEx: int -> list[int] -> list[int]
//│ bigAdd: list[int] -> list[int] -> list[int]
//│ mulByDigit: int -> list[int] -> list[int]

// FIXME: no common provs
:unify
let bigMul l1 l2 =
  let f a x =
    let (x1,x2) = x in
    let (carry,res) = a in
    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
  let base = (0, []) in
  let args = l1 (tenEx 0 l2) in
  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ [ERROR] Type `int * _ list` does not match `_ -> _`
//│    
//│         (int * _ list) ---> (?a) <--- (_ -> _) 
//│    
//│ (int * _ list) comes from
//│    l.6:    let base = (0, []) in
//│                       ^^^^^^^
//│ (?a) is assumed for
//│    l.8:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                               ^^^^
//│ 
//│    l.3:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.4:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ -> _) comes from
//│    l.-159:  let bigAdd l1 l2 =
//│                           ^^^^
//│            let add (l1,l2) = ...
//│            ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `_ list`
//│    
//│         (int * _ list) ---> (?a) <--- (_ list) 
//│    
//│ (int * _ list) comes from
//│    l.6:    let base = (0, []) in
//│                       ^^^^^^^
//│ (?a) is assumed for
//│    l.8:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                               ^^^^
//│ 
//│    l.3:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.4:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list) comes from
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                 ^^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│    
//│         (_ -> _) <--- (?a) ---> (_ list) 
//│    
//│ (_ -> _) comes from
//│    l.7:    let args = l1 (tenEx 0 l2) in
//│                       ^^
//│ (?a) is assumed for
//│    l.1:  let bigMul l1 l2 =
//│                     ^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                                       ^^
//│ 
//│    l.-149:  let rec mulByDigit i l =
//│                                  ^
//│ 
//│    l.-143:    let base = [] in removeZero (List.fold_left f base (List.rev l));;
//│                                                                            ^
//│ (_ list) comes from
//│    builtin:  let List.rev: 'a list -> 'a list
//│                         ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ -> _`
//│    
//│ `_ * _` comes from
//│    l.8:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                ^^^^^^^^^^^
//│ 
//│    l.8:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ TODO No common prov
//│ 
//│    l.3:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.4:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.-159:  let bigAdd l1 l2 =
//│                           ^^^^
//│            let add (l1,l2) = ...
//│            ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│ `_ * _` comes from
//│    l.8:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                ^^^^^^^^^^^
//│ 
//│    l.8:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ TODO No common prov
//│ 
//│    l.3:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.4:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                 ^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│ `_ * _` comes from
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.-159:  let bigAdd l1 l2 =
//│                        ^^
//│ 
//│    l.-150:    removeZero (add (padZero l1 l2));;
//│                                        ^^
//│ `_ * _` comes from
//│    l.-170:  let padZero l1 l2 =
//│                         ^^
//│ 
//│    l.-164:      else (l1, l2);;
//│                       ^^
//│ 
//│    l.-158:    let add (l1,l2) =
//│                        ^^
//│ 
//│    l.-152:      let args = List.rev (List.combine l1 l2) in
//│                                                   ^^
//│ 
//│    builtin:  let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                             ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│ `_ * _` comes from
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.-159:  let bigAdd l1 l2 =
//│                        ^^
//│ 
//│    l.-150:    removeZero (add (padZero l1 l2));;
//│                                        ^^
//│ `_ * _` comes from
//│    l.-170:  let padZero l1 l2 =
//│                         ^^
//│ 
//│    l.-165:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                                                                          ^^
//│ 
//│    builtin:  let (@): 'a list -> 'a list -> 'a list
//│                               ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│ `_ * _` comes from
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.-159:  let bigAdd l1 l2 =
//│                        ^^
//│ 
//│    l.-150:    removeZero (add (padZero l1 l2));;
//│                                        ^^
//│ `_ * _` comes from
//│    l.-170:  let padZero l1 l2 =
//│                         ^^
//│ 
//│    l.-166:      if (List.length l1) < (List.length l2)
//│                                 ^^
//│ 
//│    builtin:  let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ -> _`
//│    
//│ `_ * _` comes from
//│    l.4:      let (carry,res) = a in
//│                  ^^^^^^^^^^^
//│ 
//│    l.4:      let (carry,res) = a in
//│                                ^
//│ 
//│    l.2:    let f a x =
//│                  ^
//│ TODO No common prov
//│ 
//│    l.3:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.4:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.-159:  let bigAdd l1 l2 =
//│                           ^^^^
//│            let add (l1,l2) = ...
//│            ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│ `_ * _` comes from
//│    l.4:      let (carry,res) = a in
//│                  ^^^^^^^^^^^
//│ 
//│    l.4:      let (carry,res) = a in
//│                                ^
//│ 
//│    l.2:    let f a x =
//│                  ^
//│ TODO No common prov
//│ 
//│    l.3:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.4:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                 ^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│    
//│         (_ list) ---> (?a) <--- (_ -> _) 
//│    
//│ (_ list) comes from
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                    ^^
//│ (?a) is assumed for
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ -> _) comes from
//│    l.-159:  let bigAdd l1 l2 =
//│                           ^^^^
//│            let add (l1,l2) = ...
//│            ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│    
//│ `_ list` comes from
//│    builtin:  let List.length: 'a list -> int
//│                               ^^^^^^^
//│ 
//│    l.-165:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                                                                  ^^
//│ `_ list` comes from
//│    l.-170:  let padZero l1 l2 =
//│                         ^^
//│ 
//│    l.-150:    removeZero (add (padZero l1 l2));;
//│                                        ^^
//│ 
//│    l.-159:  let bigAdd l1 l2 =
//│                        ^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│    
//│ `_ list` comes from
//│    builtin:  let List.length: 'a list -> int
//│                               ^^^^^^^
//│ 
//│    l.-168:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                                                 ^^
//│ `_ list` comes from
//│    l.-170:  let padZero l1 l2 =
//│                         ^^
//│ 
//│    l.-150:    removeZero (add (padZero l1 l2));;
//│                                        ^^
//│ 
//│    l.-159:  let bigAdd l1 l2 =
//│                        ^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│    
//│ `_ list` comes from
//│    builtin:  let List.length: 'a list -> int
//│                               ^^^^^^^
//│ 
//│    l.-169:    if (List.length l1) > (List.length l2)
//│                               ^^
//│ `_ list` comes from
//│    l.-170:  let padZero l1 l2 =
//│                         ^^
//│ 
//│    l.-150:    removeZero (add (padZero l1 l2));;
//│                                        ^^
//│ 
//│    l.-159:  let bigAdd l1 l2 =
//│                        ^^
//│ 
//│    l.5:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ bigMul: nothing -> list[int] -> list[int]

////////// file 2361

////////// ocamlc error
// 
// File "2361.ml", line 12, characters 46-51:
// 12 |   | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//                                                    ^^^^^
// Error: This expression has type bool but an expression was expected of type
//          int

let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
let digits n = digitsOfInt (abs n);;
//│ digitsOfInt: int -> list[int]
//│ addNumbs: list[int] -> int
//│ digits: int -> list[int]

:unify
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) ---> (?a) <--- (int) 
//│    
//│ (bool) comes from
//│    l.4:    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│                                                                   ^^^^
//│ 
//│    l.4:    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.2:    match digits n with
//│            ^^^^^^^^^^^^^^^^^^^
//│            | [] -> 0 ...
//│            ^^^^^^^^^^^^^
//│ (int) comes from
//│    l.3:    | [] -> 0
//│                 ^
//│ additivePersistence: int -> (bool | int)
