:AllowTypeErrors

// file 246
let rec cloneHelper x n l =
  if n <= 0 then l else cloneHelper x (n - 1) (x :: l);;
let rec clone x n = if n < 1 then [] else cloneHelper x n [];;
let padZero l1 l2 =
  let diff = (List.length l1) - (List.length l2) in
  if diff < 0
  then (((clone 0 (-1 * diff)) @ l1), l2)
  else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | hd::tl -> if hd = 0 then removeZero tl else l;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = padZero l1 l2 in
    let base = List.combine l1 l2 in
    let args = failwith "to be implemented" in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `_ list * _` does not match `_ * _ list`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ list * _) comes from
//│    l.7:    then (((clone 0 (-1 * diff)) @ l1), l2)
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.6:    if diff < 0
//│            ^^^^^^^^^^^
//│            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list * _` does not match `_ * _`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _) 
//│    
//│ (_ list * _) comes from
//│    l.7:    then (((clone 0 (-1 * diff)) @ l1), l2)
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.6:    if diff < 0
//│            ^^^^^^^^^^^
//│            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                ^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ * _ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ * _) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                   ^^^^^^^^
//│ (?a) is assumed for
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ * _) 
//│    
//│ (_ * _ list) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                ^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ list * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _ list) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.6:    if diff < 0
//│            ^^^^^^^^^^^
//│            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.7:    then (((clone 0 (-1 * diff)) @ l1), l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list * _`
//│    
//│         (_ * _) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                   ^^^^^^^^
//│ 
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.6:    if diff < 0
//│            ^^^^^^^^^^^
//│            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.7:    then (((clone 0 (-1 * diff)) @ l1), l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list * _` does not match `_ * _ list`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ list * _) comes from
//│    l.7:    then (((clone 0 (-1 * diff)) @ l1), l2)
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.6:    if diff < 0
//│            ^^^^^^^^^^^
//│            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list * _`
//│    
//│         (_ * _) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                   ^^^^^^^^
//│ 
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.6:    if diff < 0
//│            ^^^^^^^^^^^
//│            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.7:    then (((clone 0 (-1 * diff)) @ l1), l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ * _ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ * _) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                   ^^^^^^^^
//│ (?a) is assumed for
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ * _ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ * _) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                   ^^^^^^^^
//│ 
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.6:    if diff < 0
//│            ^^^^^^^^^^^
//│            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.13:      let f a x = padZero l1 l2 in
//│                           ^^^^^^^^^^^^^
//│ 
//│    l.16:      let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│ 
//│    l.14:      let base = List.combine l1 l2 in
//│                          ^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    builtin:  let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                                    ^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ * _`
//│    
//│ `_ * _ list` comes from
//│    builtin:  let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                                       ^^^^^^^^^^^^^
//│ so this application has type `_ * _ list`
//│    l.14:      let base = List.combine l1 l2 in
//│                          ^^^^^^^^^^^^^^^^^^
//│ so this reference has type `_ * _ list`
//│    l.16:      let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│ TODO No common prov
//│ because this application has type `_ * _`
//│    l.16:      let (_,res) = List.fold_left f base args in res in
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this pattern has type `_ * _`
//│    l.16:      let (_,res) = List.fold_left f base args in res in
//│                ^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ list * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _ list) comes from
//│    builtin:  let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                                       ^^^^^^^^^^^^^
//│ 
//│    l.14:      let base = List.combine l1 l2 in
//│                          ^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.16:      let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│ 
//│    l.13:      let f a x = padZero l1 l2 in
//│                           ^^^^^^^^^^^^^
//│ 
//│    l.6:    if diff < 0
//│            ^^^^^^^^^^^
//│            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.7:    then (((clone 0 (-1 * diff)) @ l1), l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ * _ list`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ * _ list) comes from
//│    builtin:  let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                                       ^^^^^^^^^^^^^
//│ 
//│    l.14:      let base = List.combine l1 l2 in
//│                          ^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.16:      let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│ 
//│    l.13:      let f a x = padZero l1 l2 in
//│                           ^^^^^^^^^^^^^
//│ 
//│    l.6:    if diff < 0
//│            ^^^^^^^^^^^
//│            then (((clone 0 (-1 * diff)) @ l1), l2) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.8:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ cloneHelper: anything -> int -> (list[?] & 'a & 'b) -> 'a
//│   where
//│     'a := 'b
//│     'b := 'a
//│ clone: 'a -> int -> list['a]
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: (list[?] & 'a & 'b & 'c) -> 'b
//│   where
//│     'a <: 'b & 'c
//│     'b :> 'c
//│        <: 'a & 'c
//│     'c :> 'b
//│        <: 'a & 'b
//│ bigAdd: list[?] -> (list['a] & 'b & 'c & 'd) -> 'd
//│   where
//│     'b <: 'c & 'd
//│     'c :> 'd
//│        <: 'b & 'd
//│     'd :> list[int | 'a] | 'c
//│        <: 'b & 'c

// file 67 mod
type expr =
    VarX
  | VarY
  | Sine of expr
  | Cosine of expr
  | Average of expr* expr
  | Times of expr* expr
  | Thresh of expr* expr* expr* expr;;
let pi = 4.0 *. (atan 1.0);;
let rec eval (e,x,y) =
  match e with
  | VarX  -> x
  | VarY  -> y
  | Sine e' -> sin (pi *. (eval (e', x, y)))
  | Cosine e' -> cos (pi *. (eval (e', x, y)))
  | Average (e1,e2) -> ((eval (e, x, y)) +. (eval (e2, x, y))) /. 2
  | Times (e1,e2) -> (eval (e1, x, y)) *. (eval (e2, x, y))
  | Thresh (e1,e2,e3,e4) ->
      if (eval (e1, x, y)) < (eval (e2, x, y))
      then eval (e3, x, y)
      else eval (e4, x, y);;
//│ Defined type alias expr
//│ Defined class VarX
//│ Defined class VarY
//│ Defined class Sine
//│ Defined class Cosine
//│ Defined class Average
//│ Defined class Times
//│ Defined class Thresh
//│ VarX: expr
//│ VarY: expr
//│ Sine: expr -> expr
//│ Cosine: expr -> expr
//│ Average: (expr, expr,) -> expr
//│ Times: (expr, expr,) -> expr
//│ Thresh: (expr, expr, expr, expr,) -> expr
//│ pi: float
//│ eval: (expr, float & 'a & 'b & 'c & 'd, float & 'a & 'b & 'c & 'd,) -> 'b
//│   where
//│     'a <: float & 'b & 'c & 'd
//│     'b :> float | 'd
//│        <: float & 'a & 'c & 'd
//│     'd :> 'c
//│        <: float & 'a & 'b & 'c
//│     'c :> 'd
//│        <: float & 'a & 'b & 'd

// FIXME file 1087 mod
let sqsum xs =
  let f a x = match x with | [] -> 0 | h::t -> 1 in
  let base = List.hd xs in List.fold_left f base xs;;
//│ sqsum: list[list[?] & 'a] -> (int | 'a)


// file 26 mod
let rec sepConcat sep sl =
  match sl with
  | [] -> ""
  | h::t ->
      let f a x = a ^ (sep ^ x) in
      let base = h in let l = t in List.fold_left f base l;;
let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│ [ERROR] Type `(_ -> _) -> _ list -> _ list` does not match `_ list`
//│    
//│ `(_ -> _) -> _ list -> _ list` comes from
//│    builtin:  let List.map: ('a -> 'b) -> 'a list -> 'b list
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this reference has type `(_ -> _) -> _ list -> _ list`
//│    l.7:  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│                                                        ^^^^^^^^
//│ so this variable has type `(_ -> _) -> _ list -> _ list`. However it flows into `_ list`
//│    l.1:  let rec sepConcat sep sl =
//│                                ^^
//│ because this reference has type `_ list`
//│    l.2:    match sl with
//│                  ^^
//│ because this pattern has type `_ list`
//│    l.3:    | [] -> ""
//│           ^^
//│ [ERROR] Type `string` does not match `(_ * _) -> _`
//│    
//│ `string` comes from
//│    builtin:  let (^): string -> string -> string
//│                                           ^^^^^^
//│ so this operator application has type `string`
//│    l.5:        let f a x = a ^ (sep ^ x) in
//│                            ^^^^^^^^^^^^^
//│ so this application has type `string`
//│    l.6:        let base = h in let l = t in List.fold_left f base l;;
//│                                             ^^^^^^^^^^^^^^^^^^^^^^^
//│ so this match expression has type `string`
//│    l.2:    match sl with
//│            ^^^^^^^^^^^^^
//│            | [] -> "" ...
//│            ^^^^^^^^^^^^^^
//│ so this application has type `string`. However it flows into `(_ * _) -> _`
//│    l.7:  let stringOfList f l = "[" ^ ((sepConcat "; " List.map (f, l)) ^ "]");;
//│                                      ^^^^^^^^^^^^^^^^^^^^^^^
//│ sepConcat: string -> list[string] -> string
//│ stringOfList: anything -> anything -> string

// FIXME string indexing
// file 2376
let getHead h = match h with | [] -> [] | h::t -> h;;
let getTail t = match t with | [] -> [] | h::t -> t;;
let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
let rec matchHeads x y =
  match x with
  | [] -> true
  | h::t ->
      if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
let explode s =
  let rec go i =
    if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
  go 0;;
let palindrome w =
  match explode w with
  | [] -> true
  | h::t -> matchHeads (explode w) (listReverse (explode w));;
//│ [ERROR] Type `?_ | undefined` does not match `?_ | undefined`
//│    
//│         (?_ | undefined) ---> (?a) <--- (?a0) ---> (?a) <--- (?_ | undefined) 
//│    
//│ TODO: Exception empty list for (lb([(α630' | undefined)] <: 'a629'),true)
//│ Exception empty list for (ub('a628' <: ['a629']),false)
//│ TODO: Exception empty list for (lb(['a628'] <: 'a629'),true)
//│ Exception empty list for (lb([(α630' | undefined)] <: 'a629'),false)
//│ [ERROR] Type `?_ | undefined` does not match `?_ | undefined`
//│    
//│         (?_ | undefined) ---> (?a) <--- (?a0) ---> (?b) <--- (?a1) ---> (?c) <--- (?a2) ---> (?d) <--- (?_ | undefined) 
//│    
//│ TODO: Exception empty list for (lb([(α697' | undefined)] <: 'a700'),true)
//│ Exception empty list for (ub('a701' <: ['a700']),false)
//│ 
//│    l.4:    match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│                                                                 ^
//│ 
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                                            ^
//│ (?b) is assumed for
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ Exception empty list for (ub('a693' <: [[[[[[α665']]]]]]),false)
//│ (?a1) is assumed for and it flows into `?c`
//│    l.9:        if (getHead x) = (getHead y) then matchHeads t (getTail y) else false;;
//│                                 ^^^^^^^^^^^
//│ Exception empty list for (ub('a692' <: [[[[[[α661']]]]]]),false)
//│ (?a3) is assumed for and it flows into `?d`
//│    l.4:    match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│                                                                 ^
//│ Exception empty list for (lb([[[[[(α697' | undefined)]]]]] <: α690'),false)
//│ [ERROR] Type `?_ | undefined` does not match `?_ | undefined`
//│    
//│         (?_ | undefined) ---> (?a) <--- (?a0) ---> (?a) <--- (?_ | undefined) 
//│    
//│ TODO: Exception empty list for (lb([[(α648' | undefined)]] <: 'a646'),true)
//│ Exception empty list for (ub('a651' <: ['a646']),false)
//│ TODO: Exception empty list for (lb([['a652']] <: 'a646'),true)
//│ Exception empty list for (lb([[(α648' | undefined)]] <: 'a646'),false)
//│ [ERROR] Type `_ Array` does not match `string`
//│    
//│         (_ Array) <--- (?a) ---> (string) 
//│    
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                      ^^^^^^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (?a) is assumed for
//│    l.10:  let explode s =
//│                       ^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                      ^
//│ (string) comes from
//│    builtin:  let String_length: string -> int
//│                              ^^^^^^
//│ [ERROR] Type `?_ | undefined` does not match `?_ | undefined`
//│    
//│         (?_ | undefined) ---> (?b) <--- (?a) ---> (?c) <--- (?_ | undefined) 
//│    
//│ (?_ | undefined) comes from and it flows into `?b`
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                                            ^
//│ Exception empty list for (ub('a660' <: [[[α661']]]),false)
//│ TODO: Exception empty list for (lb([['a660']] <: α659'),true)
//│ Exception empty list for (lb([[[[(α678' | undefined)]]]] <: α659'),false)
//│ [ERROR] Type `?_ | undefined` does not match `?_0 | undefined`
//│    
//│         (?_ | undefined) ---> (?a) <--- (?_0 | undefined) 
//│    
//│ (?_ | undefined) comes from and it flows into `?a`
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                                            ^
//│ (?_0 | undefined) comes from
//│    l.4:    match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│                                                              ^
//│ [ERROR] Type `?_ | undefined` does not match `_ list`
//│    
//│         (?_ | undefined) ---> (?a) <--- (_ list) 
//│    
//│ (?_ | undefined) comes from
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                                            ^
//│ (?a) is assumed for
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list) comes from
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                            ^^
//│ [ERROR] Type `_ Array` does not match `_ Array`
//│    
//│         (_ Array) <--- (?a) ---> (?b) <--- (?a) ---> (_ Array) 
//│    
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                      ^^^^^^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (?a) is assumed for
//│    l.10:  let explode s =
//│                       ^
//│ TODO: Exception empty list for (lb([[[α645']]] <: α647'),true)
//│ Exception empty list for (ub(α645' <: [[[α647']]]),false)
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                   ^^^^^^
//│ [ERROR] Type `_ Array` does not match `_ Array`
//│    
//│         (_ Array) <--- (?a) ---> (_ Array) 
//│    
//│ (?a) is assumed for
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                      ^^^^^^
//│ TODO: Exception empty list for (ub(α645' <: [[[[[Array‹α697'›]]]]]),true)
//│ [ERROR] Type `_ Array` does not match `_ Array`
//│    
//│         (_ Array) <--- (?a) ---> (?b) <--- (?a) ---> (_ Array) 
//│    
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                      ^^^^^^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (?a) is assumed for
//│    l.10:  let explode s =
//│                       ^
//│ TODO: Exception empty list for (lb([[[α645']]] <: α677'),true)
//│ Exception empty list for (ub(α645' <: [[[α677']]]),false)
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                   ^^^^^^
//│ [ERROR] Type `_ Array` does not match `_ Array`
//│    
//│         (_ Array) <--- (?a) ---> (_ Array) 
//│    
//│ (?a) is assumed for
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                      ^^^^^^
//│ TODO: Exception empty list for (ub(α645' <: [[[[[Array‹α648'›]]]]]),true)
//│ [ERROR] Type `_ Array` does not match `_ Array`
//│    
//│         (_ Array) <--- (?a) ---> (_ Array) 
//│    
//│ (?a) is assumed for
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                      ^^^^^^
//│ TODO: Exception empty list for (ub(α645' <: [[[[[Array‹α697'›]]]]]),true)
//│ [ERROR] Type `_ Array` does not match `_ Array`
//│    
//│         (_ Array) <--- (?a) ---> (?b) <--- (?a) ---> (_ Array) 
//│    
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                      ^^^^^^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (?a) is assumed for
//│    l.10:  let explode s =
//│                       ^
//│ TODO: Exception empty list for (lb([[[α645']]] <: α696'),true)
//│ Exception empty list for (ub(α645' <: [[[α696']]]),false)
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                   ^^^^^^
//│ [ERROR] Type `_ list` does not match `?_0 | undefined`
//│    
//│         (_ list) ---> (?a) <--- (?_0 | undefined) 
//│    
//│ (_ list) comes from
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                               ^^
//│ (?a) is assumed for
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?_0 | undefined) comes from
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                                         ^
//│ [ERROR] Type `_ list` does not match `?_0 | undefined`
//│    
//│         (_ list) ---> (?a) <--- (?_0 | undefined) 
//│    
//│ (_ list) comes from
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                               ^^
//│ (?a) is assumed for
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                                            ^
//│ (?_0 | undefined) comes from
//│    l.4:    match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│                                                              ^
//│ [ERROR] Type `_ list` does not match `?_0 | undefined`
//│    
//│         (_ list) ---> (?a) <--- (?_0 | undefined) 
//│    
//│ (_ list) comes from
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                               ^^
//│ (?a) is assumed for
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.1:  let getHead h = match h with | [] -> [] | h::t -> h;;
//│                                                            ^
//│ (?_0 | undefined) comes from
//│    l.4:    match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│                                                              ^
//│ [ERROR] Type `string` does not match `_ Array`
//│    
//│         (string) <--- (?a) ---> (_ Array) 
//│    
//│ (string) comes from
//│    builtin:  let String_length: string -> int
//│                                 ^^^^^^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                      ^
//│ (?a) is assumed for
//│    l.10:  let explode s =
//│                       ^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                   ^^^^^^
//│ [ERROR] Type `string` does not match `_ Array`
//│    
//│         (string) <--- (?a) ---> (_ Array) 
//│    
//│ (string) comes from
//│    builtin:  let String_length: string -> int
//│                                 ^^^^^^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                      ^
//│ (?a) is assumed for
//│    l.10:  let explode s =
//│                       ^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                   ^^^^^^
//│ [ERROR] Type `string` does not match `_ Array`
//│    
//│         (string) <--- (?a) ---> (_ Array) 
//│    
//│ (string) comes from
//│    builtin:  let String_length: string -> int
//│                                 ^^^^^^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                      ^
//│ (?a) is assumed for
//│    l.10:  let explode s =
//│                       ^
//│ 
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                       ^
//│ (_ Array) comes from
//│    l.12:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                   ^^^^^^
//│ getHead: list['a] -> (list[nothing] | 'a)
//│ getTail: list['a] -> list['a]
//│ listReverse: list['a] -> list['a]
//│ matchHeads: list[?] -> list[?] -> bool
//│ explode: nothing -> list[undefined]
//│ palindrome: nothing -> bool


// file 1563
let rec sumListHelper total xs =
  match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
let rec digitsOfIntHelper n =
  if n < 1
  then []
  else if n >= 10 then (digitsOfIntHelper (n / 10)) @ [mod n 10] else [n];;
let rec digitsOfInt n = digitsOfIntHelper n;;
let rec sumList xs = sumListHelper 0 xs;;
let rec additivePersistence n = sumList digitsOfInt n;;
//│ [ERROR] Type `int` does not match `_ -> _`
//│    
//│ `int` comes from
//│    l.8:  let rec sumList xs = sumListHelper 0 xs;;
//│                                             ^
//│ so this variable has type `int`
//│    l.1:  let rec sumListHelper total xs =
//│                                ^^^^^
//│ so this reference has type `int`
//│    l.2:    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│                                  ^^^^^
//│ so this match expression has type `int`
//│    l.2:    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this application has type `int`
//│    l.2:    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│                                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this match expression has type `int`
//│    l.2:    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this application has type `int`
//│    l.8:  let rec sumList xs = sumListHelper 0 xs;;
//│                               ^^^^^^^^^^^^^^^^^^
//│ so this application has type `int`. However it flows into `_ -> _`
//│    l.9:  let rec additivePersistence n = sumList digitsOfInt n;;
//│                                       ^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│    
//│ `_ list` comes from
//│    l.2:    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│                            ^^
//│ so this reference has type `_ list`
//│    l.2:    match xs with | [] -> total | hd::tail -> sumListHelper (total + hd) tail;;
//│                  ^^
//│ so this variable has type `_ list`
//│    l.1:  let rec sumListHelper total xs =
//│                                      ^^
//│ so this reference has type `_ list`
//│    l.8:  let rec sumList xs = sumListHelper 0 xs;;
//│                                               ^^
//│ so this variable has type `_ list`
//│    l.8:  let rec sumList xs = sumListHelper 0 xs;;
//│                          ^^
//│ so this reference has type `_ list`
//│    l.9:  let rec additivePersistence n = sumList digitsOfInt n;;
//│                                                  ^^^^^^^^^^^
//│ so this recursive binding has type `_ list`. However it flows into `_ -> _`
//│    l.7:  let rec digitsOfInt n = digitsOfIntHelper n;;
//│                  ^^^^^^^^^^^
//│ because this function has type `_ -> _`
//│    l.7:  let rec digitsOfInt n = digitsOfIntHelper n;;
//│                           ^^^^^^^^^^^^^^^^^^^^^^^
//│ sumListHelper: (int & 'a & 'b) -> list[int] -> 'a
//│   where
//│     'a := 'b
//│     'b := 'a
//│ digitsOfIntHelper: int -> list[int]
//│ digitsOfInt: int -> list[int]
//│ sumList: list[int] -> int
//│ additivePersistence: anything -> nothing

// file 8776
// TODO list indexing here. skip this example?
let rec listReverse l =
  match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
let getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;
let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
let rec matchHeads x =
  match explode x with
  | h::t ->
      if (getHeads (explode x)) = []
      then true
      else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│ [ERROR] Type `?_ | undefined` does not match `?_ | undefined`
//│    
//│         (?_ | undefined) ---> (?a) <--- (?a0) ---> (?a1) <--- (?a2) ---> (?a3) <--- (?b) ---> (?a1) <--- (?_ | undefined) 
//│    
//│ TODO: Exception empty list for (lb([[(α973' | undefined)]] <: 'a961'),true)
//│ Exception empty list for (ub('a976' <: ['a961']),false)
//│ (?a0) is assumed for and it flows into `?a1`
//│    l.2:    match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│                                                                 ^
//│ Exception empty list for (ub('a977' <: [[[[[['a964']]]]]]),false)
//│ (?a2) is assumed for and it flows into `?a3`
//│    l.3:  let getHeads y = match listReverse y with | [] -> [] | h::t -> [h];;
//│                                                                          ^
//│ Exception empty list for (ub(α965' <: [[['a962']]]),false)
//│ TODO: Exception empty list for (lb([α965'] <: 'a964'),true)
//│ (?_ | undefined) comes from
//│    l.2:    match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│                                                              ^
//│ [ERROR] Type `_ Array` does not match `_ Array`
//│    
//│         (_ Array) <--- (?a) ---> (_ Array) 
//│    
//│ (?a) is assumed for
//│    l.5:  let rec matchHeads x =
//│                             ^
//│ 
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ Array) comes from
//│    l.10:        else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│                                                         ^^^^^^^^^^^^
//│ [ERROR] Type `_ Array` does not match `_ Array`
//│    
//│         (_ Array) <--- (?a) ---> (?b) <--- (?c) ---> (_ Array) 
//│    
//│ (_ Array) comes from
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                        ^^^^^^
//│ 
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                         ^
//│ (?a) is assumed for
//│    l.-369:  let explode s =
//│                         ^
//│ TODO: Exception empty list for (lb([[[α948']]] <: α972'),true)
//│ 
//│    l.10:        else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│                                                            ^^^^^^^^^^^^
//│ (?c) is assumed for
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                         ^
//│ (_ Array) comes from
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                     ^^^^^^
//│ [ERROR] Type `?_ | undefined` does not match `?_ | undefined`
//│    
//│         (?_ | undefined) ---> (?b) <--- (?a) ---> (?a0) <--- (?a1) ---> (?a2) <--- (?a3) ---> (?a4) <--- (?_ | undefined) 
//│    
//│ (?_ | undefined) comes from and it flows into `?b`
//│    l.2:    match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│                                                                 ^
//│ Exception empty list for (ub('a1011' <: [[α1008']]),false)
//│ TODO: Exception empty list for (lb([[['a1011']]] <: 'a1007'),true)
//│ (?a1) is assumed for
//│    l.2:    match l with | [] -> [] | h::t -> (listReverse t) @ [h];;
//│                                                                 ^
//│ TODO: Exception empty list for (lb([[[[['a949']]]]] <: 'a994'),true)
//│ Exception empty list for (ub('a954' <: [[[[[['a994']]]]]]),false)
//│ TODO: Exception empty list for (lb([[[['a954']]]] <: 'a1010'),true)
//│ Exception empty list for (lb([[[[[(α951' | undefined)]]]]] <: 'a1010'),false)
//│ [ERROR] Type `_ Array` does not match `_ Array`
//│    
//│         (_ Array) <--- (?a) ---> (_ Array) 
//│    
//│ (?a) is assumed for
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                        ^^^^^^
//│ TODO: Exception empty list for (ub(α1013' <: [[[[[[[[Array‹α973'›]]]]]]]]),true)
//│ [ERROR] Type `_ Array` does not match `string`
//│    
//│         (_ Array) <--- (?a) ---> (string) 
//│    
//│ (_ Array) comes from
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                        ^^^^^^
//│ 
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                         ^
//│ (?a) is assumed for
//│    l.-369:  let explode s =
//│                         ^
//│ 
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                        ^
//│ (string) comes from
//│    builtin:  let String_length: string -> int
//│                              ^^^^^^
//│ [ERROR] Type `_ Array` does not match `_ list`
//│    
//│ `_ Array` comes from
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                        ^^^^^^
//│ so this reference has type `_ Array`
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                         ^
//│ so this variable has type `_ Array`
//│    l.-369:  let explode s =
//│                         ^
//│ so this reference has type `_ Array`
//│    l.6:    match explode x with
//│                          ^
//│ so this variable has type `_ Array`
//│    l.5:  let rec matchHeads x =
//│                             ^
//│ so this application has type `_ Array`
//│    l.10:        else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│                                                            ^^^^^^^^^^^^
//│ so this match expression has type `_ Array`. However it flows into `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this reference has type `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                                                                      ^
//│ [ERROR] Type `_ Array` does not match `_ list`
//│    
//│ `_ Array` comes from
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                        ^^^^^^
//│ so this reference has type `_ Array`
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                         ^
//│ so this variable has type `_ Array`
//│    l.-369:  let explode s =
//│                         ^
//│ so this reference has type `_ Array`
//│    l.6:    match explode x with
//│                          ^
//│ so this variable has type `_ Array`
//│    l.5:  let rec matchHeads x =
//│                             ^
//│ so this application has type `_ Array`
//│    l.10:        else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│                                                            ^^^^^^^^^^^^
//│ so this match expression has type `_ Array`. However it flows into `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this reference has type `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                                                         ^^
//│ [ERROR] Type `_ Array` does not match `string`
//│    
//│         (_ Array) <--- (?a) ---> (string) 
//│    
//│ (_ Array) comes from
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                        ^^^^^^
//│ 
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                         ^
//│ (?a) is assumed for
//│    l.-369:  let explode s =
//│                         ^
//│ 
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                        ^
//│ (string) comes from
//│    builtin:  let String_length: string -> int
//│                              ^^^^^^
//│ [ERROR] Type `_ Array` does not match `_ list`
//│    
//│ `_ Array` comes from
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                        ^^^^^^
//│ so this reference has type `_ Array`
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                         ^
//│ so this variable has type `_ Array`
//│    l.-369:  let explode s =
//│                         ^
//│ so this reference has type `_ Array`
//│    l.8:        if (getHeads (explode x)) = []
//│                                      ^
//│ so this variable has type `_ Array`
//│    l.5:  let rec matchHeads x =
//│                             ^
//│ so this application has type `_ Array`
//│    l.10:        else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│                                                            ^^^^^^^^^^^^
//│ so this match expression has type `_ Array`. However it flows into `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this reference has type `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                                                                      ^
//│ [ERROR] Type `_ Array` does not match `_ list`
//│    
//│ `_ Array` comes from
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                        ^^^^^^
//│ so this reference has type `_ Array`
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                                         ^
//│ so this variable has type `_ Array`
//│    l.-369:  let explode s =
//│                         ^
//│ so this reference has type `_ Array`
//│    l.8:        if (getHeads (explode x)) = []
//│                                      ^
//│ so this variable has type `_ Array`
//│    l.5:  let rec matchHeads x =
//│                             ^
//│ so this application has type `_ Array`
//│    l.10:        else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│                                                            ^^^^^^^^^^^^
//│ so this match expression has type `_ Array`. However it flows into `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this reference has type `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                                                         ^^
//│ [ERROR] Type `string` does not match `_ list`
//│    
//│ `string` comes from
//│    builtin:  let String_length: string -> int
//│                                 ^^^^^^
//│ so this reference has type `string`
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                        ^
//│ so this variable has type `string`
//│    l.-369:  let explode s =
//│                         ^
//│ so this reference has type `string`
//│    l.8:        if (getHeads (explode x)) = []
//│                                      ^
//│ so this variable has type `string`
//│    l.5:  let rec matchHeads x =
//│                             ^
//│ so this application has type `string`
//│    l.10:        else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│                                                            ^^^^^^^^^^^^
//│ so this match expression has type `string`. However it flows into `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this reference has type `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                                                                      ^
//│ [ERROR] Type `string` does not match `_ list`
//│    
//│ `string` comes from
//│    builtin:  let String_length: string -> int
//│                                 ^^^^^^
//│ so this reference has type `string`
//│    l.-367:      if i >= (String_length s) then [] else (s[i]) :: (go (i + 1)) in
//│                                        ^
//│ so this variable has type `string`
//│    l.-369:  let explode s =
//│                         ^
//│ so this reference has type `string`
//│    l.8:        if (getHeads (explode x)) = []
//│                                      ^
//│ so this variable has type `string`
//│    l.5:  let rec matchHeads x =
//│                             ^
//│ so this application has type `string`
//│    l.10:        else if [h] = (getHeads t) then matchHeads (loseTail t) else false;;
//│                                                            ^^^^^^^^^^^^
//│ so this match expression has type `string`. However it flows into `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this reference has type `_ list`
//│    l.4:  let loseTail z = match listReverse z with | [] -> [] | h::t -> t;;
//│                                                         ^^
//│ listReverse: list['a] -> list['a]
//│ getHeads: list['a] -> list['a]
//│ loseTail: list['a] -> list['a]
//│ matchHeads: nothing -> bool

// TODO: parse correctly
let explode s =
  let rec go i =
    if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
  go 0;;
//│ [ERROR] Type `?_ | undefined` does not match `?_ | undefined`
//│    
//│         (?_ | undefined) ---> (?a) <--- (?a0) ---> (?a) <--- (?_ | undefined) 
//│    
//│ TODO: Exception empty list for (lb([(α1040' | undefined)] <: 'a1039'),true)
//│ Exception empty list for (ub('a1038' <: ['a1039']),false)
//│ TODO: Exception empty list for (lb(['a1038'] <: 'a1039'),true)
//│ Exception empty list for (lb([(α1040' | undefined)] <: 'a1039'),false)
//│ [ERROR] Type `error` does not match `int`
//│    
//│         (error) ---> (?a) <--- (int) 
//│    
//│ (error) comes from and it flows into `?a`
//│    l.3:      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                      ^^^^^^^^^^^^^^^^^
//│ 
//│    l.3:      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                 ^
//│ 
//│    l.2:    let rec go i =
//│                       ^
//│ 
//│    l.3:      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                                                                    ^^^^^^^
//│ (int) comes from
//│    builtin:  let (+): int -> int -> int
//│                                  ^^^
//│ [ERROR] Type `error` does not match `error`
//│    
//│         (error) ---> (?a) <--- (?b) ---> (?a) <--- (error) 
//│    
//│ (error) comes from and it flows into `?a`
//│    l.3:      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                      ^^^^^^^^^^^^^^^^^
//│ 
//│    l.3:      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                 ^
//│ (?b) is assumed for
//│    l.2:    let rec go i =
//│                       ^
//│ TODO: Exception empty list for (lb([[α1031']] <: α1032'),true)
//│ (error) comes from
//│    l.3:      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                   ^^^^^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: String.length
//│    
//│    l.1061:      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                       ^^^^^^^^^^^^^
//│ ╔══[ERROR] identifier not found: s.
//│    
//│    l.1061:      if i >= (String.length s) then [] else (s.[i]) :: (go (i + 1)) in
//│                                                      ^^
//│ explode: error -> list[undefined]

// file 89
// TODO: parse properly
let rec digitsOfInt n =
  let return = [n mod 10] in
  if (n / 10) <> 0
  then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)
  else return;;
let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t)
let rec digitalRoot n =
  let digits = digitsOfInt n in
  let s = sumList digits in
  if (n / 10) <> 0
  then (print_int n; print_endline " "; digitalRoot)
  else digits;;
//│ /!\ Parse error: Expected ")":4:29, found "; (digitsO" at l.1122:29:   then ((n mod 10) :: return; (digitsOfInt (n / 10)) @ return)

// file 2361
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [mod n 10];;
let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t);;
let digits n = digitsOfInt (abs n);;
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) ---> (?a) <--- (int) 
//│    
//│ (bool) comes from
//│    l.8:    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│                                                                   ^^^^
//│ 
//│    l.8:    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true;;
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.6:    match digits n with
//│            ^^^^^^^^^^^^^^^^^^^
//│            | [] -> 0 ...
//│            ^^^^^^^^^^^^^
//│ (int) comes from
//│    l.7:    | [] -> 0
//│                 ^
//│ digitsOfInt: int -> list[int]
//│ addNumbs: list[int] -> int
//│ digits: int -> list[int]
//│ additivePersistence: int -> (bool | int)

// TODO: Create adts for built in types
// file 358 mod
// type expr used from previous
let buildCosine e = Cosine e;;
let buildSine e = Sine e;;
let buildX () = VarX;;
let buildY () = VarY;;
let rec build (rand,depth) =
  let r = rand 0.4 in
  match depth with
  | 0 -> if (r mod 2) = 0 then buildX else buildY
  | d ->
      if r = 0
      then buildSine build (rand, (d - 1))
      else buildCosine build (rand, (d - 1));;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: could not find type definition d

// TODO file 1337 in separate file to avoid collisions

// file 2752 mod
let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
let x l = List.map string_of_int;;
let y = [1, 2, 3];;
let rec mulByDigit i l =
  match List.rev l with
  | [] -> []
  | h::t -> [remainder x y] @ (mulByDigit i t);;
//│ [ERROR] Type `int` does not match `_ -> _ list -> _ list`
//│    
//│ `int` comes from
//│    builtin:  let ( * ): int -> int -> int
//│                         ^^^
//│ so this reference has type `int`
//│    l.1:  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│                                                        ^
//│ so this variable has type `int`. However it flows into `_ -> _ list -> _ list`
//│    l.1:  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│                        ^
//│ because this reference has type `_ -> _ list -> _ list`
//│    l.7:    | h::t -> [remainder x y] @ (mulByDigit i t);;
//│                                 ^
//│ because this function has type `_ -> _ list -> _ list`
//│    l.2:  let x l = List.map string_of_int;;
//│             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `int` does not match `_ list`
//│    
//│ `int` comes from
//│    builtin:  let ( * ): int -> int -> int
//│                                ^^^
//│ so this reference has type `int`
//│    l.1:  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│                                                            ^
//│ so this variable has type `int`. However it flows into `_ list`
//│    l.1:  let remainder x y = if (x * y) > 10 then mod (x * y) 10 else 0;;
//│                          ^
//│ because this reference has type `_ list`
//│    l.7:    | h::t -> [remainder x y] @ (mulByDigit i t);;
//│                                   ^
//│ because this application has type `_ list`
//│    l.3:  let y = [1, 2, 3];;
//│               ^^^^^^^^^
//│ remainder: int -> int -> int
//│ x: anything -> list[int] -> list[string]
//│ y: list[(int, int, int,)]
//│ mulByDigit: anything -> list[?] -> list[int]


// file 344 mod
let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
let padLength l1 l2 = abs ((List.length l1) - (List.length l2));;
let padZero l1 l2 =
  if (List.length l1) < (List.length l2)
  then (clone 0 (padLength l1 l2)) :: l1
  else (clone 0 (padLength l1 l2)) l2;;
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│    
//│ `_ list` comes from
//│    l.1:  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                            ^^^^^^^^^^^^^^^^^^^^^^
//│ so this if-then-else expression has type `_ list`
//│    l.1:  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this application has type `_ list`. However it flows into `_ -> _`
//│    l.6:    else (clone 0 (padLength l1 l2)) l2;;
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ -> _`
//│    
//│ `_ list` comes from
//│    l.1:  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                                                                        ^^
//│ so this if-then-else expression has type `_ list`
//│    l.1:  let rec clone x n = if n > 0 then x :: (clone x (n - 1)) else [];;
//│                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this application has type `_ list`. However it flows into `_ -> _`
//│    l.6:    else (clone 0 (padLength l1 l2)) l2;;
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ clone: 'a -> int -> list['a]
//│ padLength: list[?] -> list[?] -> int
//│ padZero: list['a] -> list[?] -> list['a | list[int]]

// file 2736 [TODO different part of file has errors]
let rec addHelper (t,u) =
 match List.rev t with
 | [] -> []
 | h::t ->
    match List.rev u with
     | [] -> []
     | h'::t' ->
         if (h + h') > 10
         then (addHelper (t, t')) @ [(1 + h') + h]
         else (addHelper (t, t')) @ [h' + h];;
//│ addHelper: (list[int], list[int],) -> list[int]


:e
// file 1948
let rec helper x = if x = 0 then 1 else 10 * (helper (x - 1));;
let rec tenEx x y =
  match y with | [] -> [] | h::t -> (tenEx (x + 1) t) @ [(helper x) * h];;
let bigMul l1 l2 =
  let f a x =
    let (x1,x2) = x in
    let (carry,res) = a in
    match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
  let base = (0, []) in
  let args = l1 (tenEx 0 l2) in
  let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│ [ERROR] Type `int * _ list` does not match `_ list`
//│    
//│         (int * _ list) ---> (?a) <--- (_ list) 
//│    
//│ (int * _ list) comes from
//│    l.9:    let base = (0, []) in
//│                       ^^^^^^^
//│ (?a) is assumed for
//│    l.11:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                                ^^^^
//│ 
//│    l.6:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list) comes from
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                 ^^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│    
//│         (_ -> _) <--- (?a) ---> (_ list) 
//│    
//│ (_ -> _) comes from
//│    l.10:    let args = l1 (tenEx 0 l2) in
//│                        ^^
//│ (?a) is assumed for
//│    l.4:  let bigMul l1 l2 =
//│                     ^^
//│ 
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                                       ^^
//│ 
//│    l.-92:  let rec mulByDigit i l =
//│                                 ^
//│ 
//│    l.-91:    match List.rev l with
//│                             ^
//│ (_ list) comes from
//│    builtin:  let List.rev: 'a list -> 'a list
//│                         ^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│    
//│         (_ -> _) <--- (?a) ---> (?b) <--- (_ list) 
//│    
//│ (_ -> _) comes from
//│    l.10:    let args = l1 (tenEx 0 l2) in
//│                        ^^
//│ (?a) is assumed for
//│    l.4:  let bigMul l1 l2 =
//│                     ^^
//│ 
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                                       ^^
//│ (?b) is assumed for
//│    l.-92:  let rec mulByDigit i l =
//│                                 ^
//│ (_ list) comes from
//│    l.-89:    | h::t -> [remainder x y] @ (mulByDigit i t);;
//│                                                     ^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│ `_ * _` comes from
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this variable has type `_ * _`
//│    l.-1266:  let bigAdd l1 l2 =
//│                         ^^
//│ so this reference has type `_ * _`
//│    l.-1260:    removeZero (add (padZero l1 l2));;
//│                                         ^^
//│ so this variable has type `_ * _`. However it flows into `_ list`
//│    l.-1273:  let padZero l1 l2 =
//│                          ^^
//│ because this reference has type `_ list`
//│    l.-1270:    then (((clone 0 (-1 * diff)) @ l1), l2)
//│                                               ^^
//│ because `_ list` comes from this type expression
//│    builtin:  let (@): 'a list -> 'a list -> 'a list
//│                               ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ -> _`
//│    
//│ `_ * _` comes from
//│    l.7:      let (carry,res) = a in
//│                  ^^^^^^^^^^^
//│ so this reference has type `_ * _`
//│    l.7:      let (carry,res) = a in
//│                                ^
//│ so this variable has type `_ * _`
//│    l.5:    let f a x =
//│                  ^
//│ TODO No common prov
//│ because this let expression has type `_ -> _`
//│    l.6:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this let expression has type `_ -> _`
//│    l.7:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this match expression has type `_ -> _`
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this application has type `_ -> _`
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this function has type `_ -> _`
//│    l.-1266:  let bigAdd l1 l2 =
//│                            ^^^^
//│            let add (l1,l2) = ...
//│            ^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│ `_ * _` comes from
//│    l.7:      let (carry,res) = a in
//│                  ^^^^^^^^^^^
//│ so this reference has type `_ * _`
//│    l.7:      let (carry,res) = a in
//│                                ^
//│ so this variable has type `_ * _`
//│    l.5:    let f a x =
//│                  ^
//│ TODO No common prov
//│ because this let expression has type `_ list`
//│    l.6:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this let expression has type `_ list`
//│    l.7:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this match expression has type `_ list`
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this reference has type `_ list`
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                 ^^
//│ [ERROR] Type `_ -> _` does not match `int * _ list`
//│    
//│         (_ -> _) ---> (?a) <--- (int * _ list) 
//│    
//│ (_ -> _) comes from
//│    l.-1266:  let bigAdd l1 l2 =
//│                            ^^^^
//│            let add (l1,l2) = ...
//│            ^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.6:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.11:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                                                ^^^^
//│ (int * _ list) comes from
//│    l.9:    let base = (0, []) in
//│                    ^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ * _`
//│    
//│ `_ -> _` comes from
//│    l.-1266:  let bigAdd l1 l2 =
//│                            ^^^^
//│            let add (l1,l2) = ...
//│            ^^^^^^^^^^^^^^^^^^^^^
//│ so this application has type `_ -> _`
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this match expression has type `_ -> _`
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this let expression has type `_ -> _`
//│    l.7:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this let expression has type `_ -> _`
//│    l.6:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ TODO No common prov
//│ because this application has type `_ * _`
//│    l.11:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this pattern has type `_ * _`
//│    l.11:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│              ^^^^^^^^^^^
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│    
//│         (_ -> _) ---> (?a) <--- (_ list) 
//│    
//│ (_ -> _) comes from
//│    l.-1266:  let bigAdd l1 l2 =
//│                            ^^^^
//│            let add (l1,l2) = ...
//│            ^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list) comes from
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                 ^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│ `_ * _` comes from
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this variable has type `_ * _`
//│    l.-1266:  let bigAdd l1 l2 =
//│                         ^^
//│ so this reference has type `_ * _`
//│    l.-1260:    removeZero (add (padZero l1 l2));;
//│                                         ^^
//│ so this variable has type `_ * _`
//│    l.-1273:  let padZero l1 l2 =
//│                          ^^
//│ so this reference has type `_ * _`
//│    l.-1269:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                        ^^
//│ so this variable has type `_ * _`. However it flows into `_ list`
//│    l.-1265:    let add (l1,l2) =
//│                         ^^
//│ because this reference has type `_ list`
//│    l.-1264:      let f a x = padZero l1 l2 in
//│                                      ^^
//│ because this variable has type `_ list`
//│    l.-1273:  let padZero l1 l2 =
//│                          ^^
//│ because this reference has type `_ list`
//│    l.-1270:    then (((clone 0 (-1 * diff)) @ l1), l2)
//│                                               ^^
//│ because `_ list` comes from this type expression
//│    builtin:  let (@): 'a list -> 'a list -> 'a list
//│                               ^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│ `_ * _` comes from
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this variable has type `_ * _`
//│    l.-1266:  let bigAdd l1 l2 =
//│                         ^^
//│ so this reference has type `_ * _`
//│    l.-1260:    removeZero (add (padZero l1 l2));;
//│                                         ^^
//│ so this variable has type `_ * _`
//│    l.-1273:  let padZero l1 l2 =
//│                          ^^
//│ so this reference has type `_ * _`
//│    l.-1269:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                        ^^
//│ so this variable has type `_ * _`. However it flows into `_ list`
//│    l.-1265:    let add (l1,l2) =
//│                         ^^
//│ because this reference has type `_ list`
//│    l.-1264:      let f a x = padZero l1 l2 in
//│                                      ^^
//│ because this variable has type `_ list`
//│    l.-1273:  let padZero l1 l2 =
//│                          ^^
//│ because this reference has type `_ list`
//│    l.-1272:    let diff = (List.length l1) - (List.length l2) in
//│                                        ^^
//│ because `_ list` comes from this type expression
//│    builtin:  let List.length: 'a list -> int
//│                            ^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│    
//│ `_ list` comes from
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                    ^^
//│ so this match expression has type `_ list`
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this let expression has type `_ list`
//│    l.7:      let (carry,res) = a in
//│              ^^^^^^^^^^^^^^^^^^^^^^
//│              match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this let expression has type `_ list`
//│    l.6:      let (x1,x2) = x in
//│              ^^^^^^^^^^^^^^^^^^
//│              let (carry,res) = a in ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ TODO No common prov
//│ because this application has type `_ * _`
//│    l.11:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│                               ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this pattern has type `_ * _`
//│    l.11:    let (carry,res) = List.fold_left f base args in [carry] @ res;;
//│              ^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│    
//│ `_ list` comes from
//│    builtin:  let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                ^^^^^^^
//│ so this reference has type `_ list`
//│    l.-1263:      let base = List.combine l1 l2 in
//│                                          ^^
//│ so this variable has type `_ list`. However it flows into `_ * _`
//│    l.-1265:    let add (l1,l2) =
//│                         ^^
//│ because this reference has type `_ * _`
//│    l.-1269:    else if diff > 0 then (l1, ((clone 0 diff) @ l2)) else (l1, l2);;
//│                                                                        ^^
//│ because this variable has type `_ * _`
//│    l.-1273:  let padZero l1 l2 =
//│                          ^^
//│ because this reference has type `_ * _`
//│    l.-1260:    removeZero (add (padZero l1 l2));;
//│                                         ^^
//│ because this variable has type `_ * _`
//│    l.-1266:  let bigAdd l1 l2 =
//│                         ^^
//│ because this tuple literal has type `_ * _`
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list` does not match `_ * _`
//│    
//│ `_ list` comes from
//│    builtin:  let List.length: 'a list -> int
//│                               ^^^^^^^
//│ so this reference has type `_ list`
//│    l.-1272:    let diff = (List.length l1) - (List.length l2) in
//│                                        ^^
//│ so this variable has type `_ list`. However it flows into `_ * _`
//│    l.-1273:  let padZero l1 l2 =
//│                          ^^
//│ because this reference has type `_ * _`
//│    l.-1260:    removeZero (add (padZero l1 l2));;
//│                                         ^^
//│ because this variable has type `_ * _`
//│    l.-1266:  let bigAdd l1 l2 =
//│                         ^^
//│ because this tuple literal has type `_ * _`
//│    l.8:      match x2 with | [] -> [] | h::t -> bigAdd ((mulByDigit h l1), res) in
//│                                                     ^^^^^^^^^^^^^^^^^^^^^^^^
//│ helper: int -> int
//│ tenEx: int -> list[int] -> list[int]
//│ bigMul: nothing -> list[int] -> list[int]

// file 335
let fixpointHelper f =
  match f with | (num,expr) -> if expr then (num, true) else (num, false);;
let rec wwhile (f,b) =
  match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│ [ERROR] Type `_ * bool` does not match `_ -> _`
//│    
//│ `_ * bool` comes from
//│    l.2:    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│                                                                       ^^^^^^^^^^^^
//│ so this if-then-else expression has type `_ * bool`. However it flows into `_ -> _`
//│    l.2:    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this let expression has type `_ -> _`
//│    l.2:    match f with | (num,expr) -> if expr then (num, true) else (num, false);;
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ because this application has type `_ -> _`
//│    l.5:  let fixpoint (f,b) = wwhile ((fixpointHelper f), b);;
//│                                       ^^^^^^^^^^^^^^^^^^
//│ because this variable has type `_ -> _`
//│    l.3:  let rec wwhile (f,b) =
//│                          ^
//│ because this reference has type `_ -> _`
//│    l.4:    match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│               ^
//│ fixpointHelper: ('a, bool,) -> ('a, bool,)
//│ wwhile: (('a | 'b) -> ('a & 'b & 'c & 'd, bool,), 'a,) -> 'c
//│   where
//│     'b <: 'c & 'd
//│     'c :> 'b | 'd
//│        <: 'b & 'd
//│     'd :> 'b | 'c
//│        <: 'b & 'c
//│ fixpoint: ((anything, bool,), anything,) -> nothing

// FIXME: no common provs
// file 3 mod
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let padZero l1 l2 =
  let numZeros = (List.length l1) - (List.length l2) in
  let absNumZeros = abs numZeros in
  if numZeros = 0
  then (l1, l2)
  else
    (let listZeros = clone 0 absNumZeros in
     if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
let rec removeZero l =
  match l with | [] -> [] | 0::t -> removeZero t | h::t -> l;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x =
      let (carry,currentSum) = a in
      if x = []
      then (0, (carry :: currentSum))
      else
        (let (toSum1,toSum2) = x in
         let intermediateValue = (toSum1 + toSum2) + carry in
         let valueToAddToArray = intermediateValue mod 10 in
         let carry = intermediateValue / 10 in
         (carry, (valueToAddToArray :: currentSum))) in
    let base = (0, []) in
    let args = List.rev (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `_ list * _` does not match `_ * _ list`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ list * _) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                                                ^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                 ^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ list * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _ list) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                    ^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                                             ^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list * _`
//│    
//│         (_ * _) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _) comes from
//│    l.6:    then (l1, l2)
//│                 ^^^^^^^^
//│ (?a) is assumed for
//│    l.5:    if numZeros = 0
//│            ^^^^^^^^^^^^^^^
//│            then (l1, l2) ...
//│            ^^^^^^^^^^^^^^^^^
//│ 
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                                             ^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ * _ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ * _) comes from
//│    l.6:    then (l1, l2)
//│                 ^^^^^^^^
//│ (?a) is assumed for
//│    l.5:    if numZeros = 0
//│            ^^^^^^^^^^^^^^^
//│            then (l1, l2) ...
//│            ^^^^^^^^^^^^^^^^^
//│ 
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                 ^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ list * _` does not match `_ * _`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _) 
//│    
//│ (_ list * _) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                                                ^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.5:    if numZeros = 0
//│            ^^^^^^^^^^^^^^^
//│            then (l1, l2) ...
//│            ^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.6:    then (l1, l2)
//│              ^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ * _) 
//│    
//│ (_ * _ list) comes from
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│                                    ^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.9:       if numZeros > 0 then (l1, (listZeros @ l2)) else ((listZeros @ l1), l2));;
//│               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.5:    if numZeros = 0
//│            ^^^^^^^^^^^^^^^
//│            then (l1, l2) ...
//│            ^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.6:    then (l1, l2)
//│              ^^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `int * _ list`
//│    
//│         (int * _ list) ---> (?a) <--- (int * _ list) 
//│    
//│ (int * _ list) comes from
//│    l.17:        then (0, (carry :: currentSum))
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.16:        if x = []
//│                 ^^^^^^^^^
//│                then (0, (carry :: currentSum)) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.15:        let (carry,currentSum) = a in
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│                if x = [] ...
//│                ^^^^^^^^^^^^^
//│ 
//│    l.26:      let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│ (int * _ list) comes from
//│    l.24:      let base = (0, []) in
//│                       ^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `int * _ list`
//│    
//│         (int * _ list) ---> (?a) <--- (int * _ list) 
//│    
//│ (int * _ list) comes from
//│    l.23:           (carry, (valueToAddToArray :: currentSum))) in
//│                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.19:          (let (toSum1,toSum2) = x in
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│                   let intermediateValue = (toSum1 + toSum2) + carry in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.16:        if x = []
//│                 ^^^^^^^^^
//│                then (0, (carry :: currentSum)) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.15:        let (carry,currentSum) = a in
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│                if x = [] ...
//│                ^^^^^^^^^^^^^
//│ 
//│    l.26:      let (_,res) = List.fold_left f base args in res in
//│                                              ^^^^
//│ (int * _ list) comes from
//│    l.24:      let base = (0, []) in
//│                       ^^^^^^^
//│ [ERROR] Type `int * _ list` does not match `int * _ list`
//│    
//│         (int * _ list) ---> (?a) <--- (int * _ list) 
//│    
//│ (int * _ list) comes from
//│    l.23:           (carry, (valueToAddToArray :: currentSum))) in
//│                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.19:          (let (toSum1,toSum2) = x in
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│                   let intermediateValue = (toSum1 + toSum2) + carry in ...
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.16:        if x = []
//│                 ^^^^^^^^^
//│                then (0, (carry :: currentSum)) ...
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (int * _ list) comes from
//│    l.17:        then (0, (carry :: currentSum))
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│         (_ * _) <--- (?a) ---> (?b) <--- (_ list) 
//│    
//│ (_ * _) comes from
//│    l.19:          (let (toSum1,toSum2) = x in
//│                        ^^^^^^^^^^^^^^^
//│ 
//│    l.19:          (let (toSum1,toSum2) = x in
//│                                          ^
//│ (?a) is assumed for
//│    l.14:      let f a x =
//│                       ^
//│ (?a) is assumed for and it flows into `?b`
//│    l.16:        if x = []
//│                    ^
//│ (_ list) comes from
//│    l.16:        if x = []
//│                     ^^
//│ [ERROR] Type `_ * _` does not match `_ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ list) 
//│    
//│ (_ * _) comes from
//│    builtin:  let List.combine: 'a list -> 'b list -> ('a * 'b) list
//│                                                       ^^^^^^^
//│ 
//│    l.14:      let f a x =
//│                       ^
//│ (?a) is assumed for
//│    l.16:        if x = []
//│                    ^
//│ (_ list) comes from
//│    l.16:        if x = []
//│                     ^^
//│ clone: 'a -> int -> list['a]
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: (list[int] & 'a & 'b) -> 'a
//│   where
//│     'a := 'b
//│     'b := 'a
//│ bigAdd: list[int] -> list[int] -> list[int]

// file 1935
let rec clone x n = if n <= 0 then [] else x :: (clone x (n - 1));;
let addTuple (l1,l2) = l1 + l2;;
let padZero l1 l2 =
  if (List.length l1) > (List.length l2)
  then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
  else
    if (List.length l1) < (List.length l2)
    then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
    else (l1, l2);;
let rec removeZero l =
  match l with | [] -> [] | h::t -> if h = 0 then removeZero t else h :: t;;
let bigAdd l1 l2 =
  let add (l1,l2) =
    let f a x = (a + x) mod 10 in
    let base = 0 in
    let args = List.map addTuple (List.combine l1 l2) in
    let (_,res) = List.fold_left f base args in res in
  removeZero (add (padZero l1 l2));;
//│ [ERROR] Type `_ list * _` does not match `_ * _`
//│    
//│         (_ list * _) ---> (?a) <--- (_ * _) 
//│    
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                ^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ list * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ * _) 
//│    
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                ^^^^^^^^
//│ [ERROR] Type `_ * _ list` does not match `_ list * _`
//│    
//│         (_ * _ list) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ list * _`
//│    
//│         (_ * _) ---> (?a) <--- (_ list * _) 
//│    
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                   ^^^^^^^^
//│ (?a) is assumed for
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ list * _) comes from
//│    l.8:      then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2)
//│                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `_ * _ list`
//│    
//│         (_ * _) ---> (?a) <--- (_ * _ list) 
//│    
//│ (_ * _) comes from
//│    l.9:      else (l1, l2);;
//│                   ^^^^^^^^
//│ 
//│    l.7:      if (List.length l1) < (List.length l2)
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│              then (((clone 0 ((List.length l2) - (List.length l1))) @ l1), l2) ...
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.4:    if (List.length l1) > (List.length l2)
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│            then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2)) ...
//│            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (_ * _ list) comes from
//│    l.5:    then (l1, ((clone 0 ((List.length l1) - (List.length l2))) @ l2))
//│              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ [ERROR] Type `_ * _` does not match `int`
//│    
//│         (_ * _) <--- (?a) ---> (int) 
//│    
//│ (_ * _) comes from
//│    l.17:      let (_,res) = List.fold_left f base args in res in
//│                   ^^^^^^^
//│ (?a) is assumed for
//│    l.17:      let (_,res) = List.fold_left f base args in res in
//│                             ^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ 
//│    l.14:      let f a x = (a + x) mod 10 in
//│                     ^
//│ 
//│    l.14:      let f a x = (a + x) mod 10 in
//│                            ^
//│ (int) comes from
//│    builtin:  let (+): int -> int -> int
//│                    ^^^
//│ clone: 'a -> int -> list['a]
//│ addTuple: (int, int,) -> int
//│ padZero: (list['a] & 'b) -> (list['c] & 'd) -> (list[int | 'a] | 'b, list[int | 'c] | 'd,)
//│ removeZero: list['a] -> list['a]
//│ bigAdd: list[int] -> list[int] -> list[nothing]



// file 1907
let intboolf f x = ((f x), ((f x) < 1));;
let fixpoint (f,b) = wwhile (intboolf, b);;
let rec wwhile (f,b) =
  match f b with | (b',c') -> if c' then wwhile (f, b') else b';;
//│ [ERROR] Type `_ -> (_ * bool)` does not match `_ * _`
//│    
//│ `_ -> (_ * bool)` comes from
//│    l.1:  let intboolf f x = ((f x), ((f x) < 1));;
//│                         ^^^^^^^^^^^^^^^^^^^^^^^^
//│ so this application has type `_ -> (_ * bool)`. However it flows into `_ * _`
//│    l.-429:    match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│                     ^^^
//│ because this pattern has type `_ * _`
//│    l.-429:    match f b with | (num,expr) -> if expr then wwhile (f, num) else num;;
//│                             ^^^^^^^^^^
//│ intboolf: ('a -> 'b) -> 'a -> ('b, bool,)
//│ fixpoint: (anything, nothing -> anything,) -> nothing
//│ wwhile: (('a | 'b) -> ('a & 'b & 'c & 'd, bool,), 'a,) -> 'c
//│   where
//│     'b <: 'c & 'd
//│     'c :> 'b | 'd
//│        <: 'b & 'd
//│     'd :> 'b | 'c
//│        <: 'b & 'c



// file 2047
let identity a = a;;
let pipe fs =
  let f a x = a x in let base = identity in List.fold_left f base fs;;
//│ identity: 'a -> 'a
//│ pipe: list['a & 'b & 'c & 'd & 'e] -> 'a
//│   where
//│     'a :> ('a & 'b & 'd & 'e) -> ('b | 'c) | 'b | 'c | 'e
//│        <: 'd
//│     'd <: 'c -> 'e
//│     'e :> 'b | 'c
//│        <: 'a & 'd


// file 830
// TODO: fix how match case is done
let modulus ss = ss mod 10;;
let rec digitsOfInt n =
  if n <= 0
  then []
  else (match n with | x -> (digitsOfInt (n / 10)) @ [modulus x]);;
let lt10 q = q < 10;;
let rec sumList xs = match xs with | [] -> 0 | h::t -> h + (sumList t);;
let rec additivePersistence n =
  if lt10 n
  then n
  else
    (match n with
     | n -> let x_ = digitsOfInt n in sumList x_ additivePersistence n);;
//│ /!!!\ Uncaught error: java.lang.Exception: Internal Error: could not find type definition x


// FIXME investigate
// file 1770 (TODO fix nested flows)
let rec filter l a =
  match l with
  | [] -> []
  | h::t -> if a = h then filter t a else h :: (filter t a);;
let removeDuplicates l =
  let rec helper (seen,rest) =
    match rest with
    | [] -> seen
    | h::t ->
        let seen' = h in
        let rest' = h :: (filter (t h)) in helper (seen', rest') in
  List.rev (helper ([], l));;
//│ [ERROR] Type `_ -> _` does not match `_ list`
//│    
//│ `_ -> _` comes from
//│    l.1:  let rec filter l a =
//│                           ^^^
//│            match l with ...
//│            ^^^^^^^^^^^^^^^^
//│ so this application has type `_ -> _`. However it flows into `_ list`
//│    l.11:          let rest' = h :: (filter (t h)) in helper (seen', rest') in
//│                                 ^^^^^^^^^^^^^^
//│ filter: list['a] -> anything -> list['a]
//│ removeDuplicates: list[list['a]] -> list['a]


// file 0221
let fu x b = (x, (b < (x b)));;
let rec wwhile (f,b) =
  let temp = f b in
  match temp with | (a,boolean) -> if boolean then wwhile (f, a) else a;;
let fixpoint (f,b) = wwhile ((fu f), b);;
//│ fu: ('a -> anything & 'b) -> 'a -> ('b, bool,)
//│ wwhile: (('a | 'b) -> ('a & 'b & 'c & 'd, bool,), 'a,) -> 'c
//│   where
//│     'b <: 'c & 'd
//│     'c :> 'b | 'd
//│        <: 'b & 'd
//│     'd :> 'b | 'c
//│        <: 'b & 'c
//│ fixpoint: (('a | 'b) -> anything & 'a & 'b & 'c & 'd, 'a,) -> ('d | 'b)
//│   where
//│     'b <: 'c & 'd
//│     'c :> 'd | 'b
//│        <: 'b & 'd
//│     'd :> 'c | 'b
//│        <: 'b & 'c

// file 2338
:unify
let rec assoc (d,k,l) =
  match l with
  | [] -> d
  | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│ [ERROR] Type `_ * _ * _` does not match `_ -> _`
//│    
//│         (?a * _ * _) <--- (?a) ---> (_ -> _) 
//│    
//│ (?a * _ * _) comes from
//│    l.1:  let rec assoc (d,k,l) =
//│                        ^^^^^^^
//│ 
//│    l.4:    | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│                                                                    ^
//│ (?a) is assumed for
//│    l.1:  let rec assoc (d,k,l) =
//│                         ^
//│ 
//│    l.3:    | [] -> d
//│                    ^
//│ 
//│    l.2:    match l with
//│            ^^^^^^^^^^^^
//│            | [] -> d ...
//│            ^^^^^^^^^^^^^
//│ (_ -> _) comes from
//│    l.4:    | h::t -> let (f,s) = h in if k = f then s h else assoc d k t;;
//│                                                           ^^^^^^^
//│ assoc: ('b, 'c, list[(anything, 'a -> ('d & 'e & 'f & 'g),) & 'a],) -> 'e
//│   where
//│     'b <: ('b, 'c, list[(anything, 'a -> ('d & 'e & 'f & 'g),) & 'a],) & 'd & 'e
//│     'd <: 'c -> list['a] -> 'h
//│     'h <: 'd & 'e & 'f & 'g
//│     'e :> 'b | 'f | 'g
//│        <: 'd
//│     'f :> 'g
//│        <: 'd & 'e
//│     'g :> 'h
//│        <: 'd & 'e & 'f
