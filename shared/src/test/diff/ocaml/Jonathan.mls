
:e
:unify
let h y = (not y, (if true then y else 5))
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) <--- (?a) ---> (?b) <--- (int) 
//│    
//│ (bool) comes from
//│    builtin:  let not: bool -> bool
//│                       ^^^^
//│ 
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                         ^
//│ (?a) is assumed for
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                ^
//│ 
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                                          ^
//│ (?b) is assumed for
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                            ^^^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                                              ^
//│ h: (bool & 'a) -> (bool, int | 'a,)





:e
:unify
let h y = (not y, (if true then y else 5))
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) <--- (?a) ---> (?b) <--- (int) 
//│    
//│ (bool) comes from
//│    builtin:  let not: bool -> bool
//│                       ^^^^
//│ 
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                         ^
//│ (?a) is assumed for
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                ^
//│ 
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                                          ^
//│ (?b) is assumed for
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                            ^^^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  let h y = (not y, (if true then y else 5))
//│                                              ^
//│ h: (bool & 'a) -> (bool, int | 'a,)



:e
:unify
let confluence z = if true then z else 5
confluence true
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) ---> (?a) <--- (int) 
//│    
//│ (bool) comes from
//│    l.2:  confluence true
//│                     ^^^^
//│ 
//│    l.1:  let confluence z = if true then z else 5
//│                         ^
//│ 
//│    l.1:  let confluence z = if true then z else 5
//│                                          ^
//│ (?a) is assumed for
//│    l.1:  let confluence z = if true then z else 5
//│                             ^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.1:  let confluence z = if true then z else 5
//│                                              ^
//│ confluence: 'a -> (int | 'a)
//│ res: bool | int


let mkpair x y = (x, confluence y)
let conflict x = mkpair (not x) x
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) <--- (?a) ---> (?b) <--- (int) 
//│    
//│ (bool) comes from
//│    builtin:  let not: bool -> bool
//│                       ^^^^
//│ 
//│    l.2:  let conflict x = mkpair (not x) x
//│                                       ^
//│ (?a) is assumed for
//│    l.2:  let conflict x = mkpair (not x) x
//│                       ^
//│ 
//│    l.2:  let conflict x = mkpair (not x) x
//│                                          ^
//│ 
//│    l.1:  let mkpair x y = (x, confluence y)
//│                       ^
//│ 
//│    l.1:  let mkpair x y = (x, confluence y)
//│                                          ^
//│ 
//│    l.-24:  let confluence z = if true then z else 5
//│                           ^
//│ 
//│    l.-24:  let confluence z = if true then z else 5
//│                                            ^
//│ (?b) is assumed for
//│    l.-24:  let confluence z = if true then z else 5
//│                               ^^^^^^^^^^^^^^^^^^^^^
//│ (int) comes from
//│    l.-24:  let confluence z = if true then z else 5
//│                                                ^
//│ mkpair: 'a -> 'b -> ('a, int | 'b,)
//│ conflict: (bool & 'a) -> (bool, int | 'a,)



// TODO show nested unification error
// :e
let rec digitsOfInt n =
  if n <= 0 then [] else (digitsOfInt (n / 10)) @ [n mod 10]
//│ digitsOfInt: int -> list[int]

let rec addNumbs n = match n with | [] -> 0 | h::t -> h + (addNumbs t)
//│ addNumbs: list[int] -> int

// show nested unification error
// :e
// :tex
let digits n = digitsOfInt (abs n)
//│ digits: int -> list[int]

:e
let rec additivePersistence n =
  match digits n with
  | [] -> 0
  | h::t -> if (addNumbs (h :: t)) >= 10 then false else true
//│ [ERROR] Type `bool` does not match `int`
//│    
//│         (bool) ---> (?a) <--- (int) 
//│    
//│ (bool) comes from
//│    l.4:    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true
//│                                                                   ^^^^^
//│ 
//│    l.4:    | h::t -> if (addNumbs (h :: t)) >= 10 then false else true
//│                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ (?a) is assumed for
//│    l.2:    match digits n with
//│            ^^^^^^^^^^^^^^^^^^^
//│            | [] -> 0 ...
//│            ^^^^^^^^^^^^^
//│ (int) comes from
//│    l.3:    | [] -> 0
//│                 ^
//│ additivePersistence: int -> (bool | int)


let y x = [x]
let k a = if a then [2] else y true
//│ y: 'a -> list['a]
//│ k: bool -> list[bool | int]
